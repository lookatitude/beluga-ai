// Package multimodal provides a unified interface for multimodal model operations.
package multimodal

import (
	"context"
	"fmt"
	"io"
	"mime"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
)

// MultimodalInput represents a multimodal input containing one or more content types.
type MultimodalInput struct {
	// ID is a unique identifier for this input
	ID string

	// ContentBlocks contains the content blocks (text, images, audio, video)
	ContentBlocks []*ContentBlock

	// Metadata contains additional metadata
	Metadata map[string]any

	// Format is the preferred format ("base64", "url", "file_path")
	Format string

	// Routing contains routing instructions for content blocks
	Routing *RoutingConfig

	// CreatedAt is the creation timestamp
	CreatedAt time.Time
}

// MultimodalOutput represents a multimodal output generated by a model.
type MultimodalOutput struct {
	// ID is a unique identifier for this output
	ID string

	// InputID references the input that produced this output
	InputID string

	// ContentBlocks contains the generated content blocks
	ContentBlocks []*ContentBlock

	// Metadata contains additional metadata
	Metadata map[string]any

	// Confidence is the confidence score (0.0-1.0)
	Confidence float32

	// Provider is the provider that generated the output
	Provider string

	// Model is the model that generated the output
	Model string

	// CreatedAt is the creation timestamp
	CreatedAt time.Time
}

// ContentBlock represents a single content block within multimodal input/output.
type ContentBlock struct {
	// Type is the content type ("text", "image", "audio", "video")
	Type string

	// Data is the raw content data (base64 encoded or raw bytes)
	Data []byte

	// URL is the URL to the content (if applicable)
	URL string

	// FilePath is the file path to the content (if applicable)
	FilePath string

	// MIMEType is the MIME type of the content (e.g., "image/png", "audio/mpeg")
	MIMEType string

	// Format is the format (e.g., "png", "mp3", "mp4")
	Format string

	// Size is the size in bytes
	Size int64

	// Metadata contains additional metadata
	Metadata map[string]any
}

// Content block factory functions

// NewContentBlock creates a new content block from raw data.
// contentType must be one of: "text", "image", "audio", "video".
// The MIME type is automatically detected from the data if not provided.
// Returns an error if the content type is invalid or empty.
//
// Example:
//
//	block, err := NewContentBlock("text", []byte("Hello, world!"))
//	if err != nil {
//	    log.Fatal(err)
//	}
func NewContentBlock(contentType string, data []byte) (*ContentBlock, error) {
	if contentType == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlock", ErrCodeInvalidInput,
			"content type cannot be empty", nil)
	}

	validTypes := []string{"text", "image", "audio", "video"}
	isValid := false
	for _, t := range validTypes {
		if contentType == t {
			isValid = true
			break
		}
	}
	if !isValid {
		return nil, NewMultimodalErrorWithMessage("NewContentBlock", ErrCodeInvalidInput,
			fmt.Sprintf("invalid content type: %s (must be one of: text, image, audio, video)", contentType), nil)
	}

	block := &ContentBlock{
		Type:     contentType,
		Data:     data,
		Size:     int64(len(data)),
		Metadata: make(map[string]any),
	}

	// Detect MIME type if not provided
	if contentType == "text" {
		block.MIMEType = "text/plain"
	} else {
		// Try to detect MIME type from data
		mimeType := http.DetectContentType(data)
		block.MIMEType = mimeType
	}

	return block, nil
}

// NewContentBlockFromURL creates a new content block from a URL.
// The content is fetched from the URL and the MIME type is determined from the HTTP response headers.
// contentType must be one of: "text", "image", "audio", "video".
// Returns an error if the URL cannot be fetched or the content type is invalid.
//
// Example:
//
//	block, err := NewContentBlockFromURL(ctx, "image", "https://example.com/image.png")
//	if err != nil {
//	    log.Fatal(err)
//	}
func NewContentBlockFromURL(ctx context.Context, contentType, url string) (*ContentBlock, error) {
	if contentType == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromURL", ErrCodeInvalidInput,
			"content type cannot be empty", nil)
	}
	if url == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromURL", ErrCodeInvalidInput,
			"URL cannot be empty", nil)
	}

	// Fetch the content from URL
	resp, err := http.Get(url)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromURL", ErrCodeProviderError)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromURL", ErrCodeProviderError,
			fmt.Sprintf("failed to fetch URL: status %d", resp.StatusCode), nil)
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromURL", ErrCodeProviderError)
	}

	block := &ContentBlock{
		Type:     contentType,
		URL:      url,
		Data:     data,
		Size:     int64(len(data)),
		MIMEType: resp.Header.Get("Content-Type"),
		Metadata: make(map[string]any),
	}

	// Extract format from MIME type or URL
	if block.MIMEType != "" {
		exts, _ := mime.ExtensionsByType(block.MIMEType)
		if len(exts) > 0 {
			block.Format = strings.TrimPrefix(exts[0], ".")
		}
	}

	return block, nil
}

// NewContentBlockFromFile creates a new content block from a file path.
// The file is read and the MIME type is determined from the file extension.
// contentType must be one of: "text", "image", "audio", "video".
// Returns an error if the file cannot be read or the content type is invalid.
//
// Example:
//
//	block, err := NewContentBlockFromFile(ctx, "image", "/path/to/image.jpg")
//	if err != nil {
//	    log.Fatal(err)
//	}
func NewContentBlockFromFile(ctx context.Context, contentType, filePath string) (*ContentBlock, error) {
	if contentType == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromFile", ErrCodeInvalidInput,
			"content type cannot be empty", nil)
	}
	if filePath == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromFile", ErrCodeInvalidInput,
			"file path cannot be empty", nil)
	}

	// Check if file exists
	info, err := os.Stat(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, NewMultimodalErrorWithMessage("NewContentBlockFromFile", ErrCodeFileNotFound,
				fmt.Sprintf("file not found: %s", filePath), err)
		}
		return nil, WrapError(err, "NewContentBlockFromFile", ErrCodeFileNotFound)
	}

	// Read file
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromFile", ErrCodeFileNotFound)
	}

	// Detect MIME type from file extension
	ext := strings.ToLower(filepath.Ext(filePath))
	mimeType := mime.TypeByExtension(ext)
	if mimeType == "" {
		mimeType = http.DetectContentType(data)
	}

	block := &ContentBlock{
		Type:     contentType,
		FilePath: filePath,
		Data:     data,
		Size:     info.Size(),
		MIMEType: mimeType,
		Format:   strings.TrimPrefix(ext, "."),
		Metadata: make(map[string]any),
	}

	return block, nil
}

// Validate validates the content block.
func (cb *ContentBlock) Validate() error {
	// Validate type
	validTypes := []string{"text", "image", "audio", "video"}
	isValid := false
	for _, t := range validTypes {
		if cb.Type == t {
			isValid = true
			break
		}
	}
	if !isValid {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			fmt.Sprintf("invalid content type: %s", cb.Type), nil)
	}

	// Must have at least one data source
	if len(cb.Data) == 0 && cb.URL == "" && cb.FilePath == "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"content block must have at least one of: Data, URL, or FilePath", nil)
	}

	// Validate size
	if cb.Size < 0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"size must be >= 0", nil)
	}

	return nil
}

// MultimodalInputOption defines a function type for MultimodalInput options.
// Options can be used to configure routing, metadata, and format preferences.
type MultimodalInputOption func(*MultimodalInput)

// WithRouting sets the routing configuration for the multimodal input.
// This allows specifying which providers should handle different content types.
//
// Example:
//
//	input, _ := NewMultimodalInput(blocks,
//	    WithRouting(&RoutingConfig{
//	        Strategy:      "manual",
//	        TextProvider:  "openai",
//	        ImageProvider: "gemini",
//	    }),
//	)
func WithRouting(routing *RoutingConfig) MultimodalInputOption {
	return func(input *MultimodalInput) {
		input.Routing = routing
	}
}

// WithMetadata sets additional metadata for the multimodal input.
// Metadata can be used to pass context, user information, or other custom data.
//
// Example:
//
//	input, _ := NewMultimodalInput(blocks,
//	    WithMetadata(map[string]any{
//	        "user_id": "user-123",
//	        "session_id": "session-456",
//	    }),
//	)
func WithMetadata(metadata map[string]any) MultimodalInputOption {
	return func(input *MultimodalInput) {
		if input.Metadata == nil {
			input.Metadata = make(map[string]any)
		}
		for k, v := range metadata {
			input.Metadata[k] = v
		}
	}
}

// WithFormat sets the preferred format for content blocks.
// Format must be one of: "base64", "url", "file_path".
// The normalizer will attempt to convert content blocks to this format.
//
// Example:
//
//	input, _ := NewMultimodalInput(blocks, WithFormat("url"))
func WithFormat(format string) MultimodalInputOption {
	return func(input *MultimodalInput) {
		input.Format = format
	}
}

// NewMultimodalInput creates a new multimodal input with the given content blocks and options.
// At least one content block is required. All content blocks are validated before creating the input.
// Options can be used to configure routing, metadata, and format preferences.
//
// Example:
//
//	textBlock, _ := NewContentBlock("text", []byte("Hello"))
//	imageBlock, _ := NewContentBlockFromURL(ctx, "image", "https://example.com/image.png")
//	input, err := NewMultimodalInput([]*ContentBlock{textBlock, imageBlock})
//	if err != nil {
//	    log.Fatal(err)
//	}
func NewMultimodalInput(contentBlocks []*ContentBlock, opts ...MultimodalInputOption) (*MultimodalInput, error) {
	if len(contentBlocks) == 0 {
		return nil, NewMultimodalErrorWithMessage("NewMultimodalInput", ErrCodeInvalidInput,
			"must have at least one content block", nil)
	}

	// Validate all content blocks
	for i, block := range contentBlocks {
		if err := block.Validate(); err != nil {
			return nil, NewMultimodalErrorWithMessage("NewMultimodalInput", ErrCodeInvalidInput,
				fmt.Sprintf("content block %d validation failed", i), err)
		}
	}

	input := &MultimodalInput{
		ID:            uuid.New().String(),
		ContentBlocks: contentBlocks,
		Metadata:      make(map[string]any),
		Format:        "base64", // default
		CreatedAt:     time.Now(),
	}

	// Apply options
	for _, opt := range opts {
		opt(input)
	}

	// Validate routing if provided
	if input.Routing != nil {
		if err := input.Routing.Validate(context.Background()); err != nil {
			return nil, err
		}
	}

	return input, nil
}

// Validate validates the multimodal input.
func (mi *MultimodalInput) Validate() error {
	if len(mi.ContentBlocks) == 0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"must have at least one content block", nil)
	}

	// Validate all content blocks
	for i, block := range mi.ContentBlocks {
		if err := block.Validate(); err != nil {
			return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
				fmt.Sprintf("content block %d validation failed", i), err)
		}
	}

	// Validate format
	validFormats := []string{"base64", "url", "file_path"}
	isValid := false
	for _, f := range validFormats {
		if mi.Format == f {
			isValid = true
			break
		}
	}
	if !isValid && mi.Format != "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidFormat,
			fmt.Sprintf("invalid format: %s (must be one of: base64, url, file_path)", mi.Format), nil)
	}

	// Validate routing if provided
	if mi.Routing != nil {
		if err := mi.Routing.Validate(context.Background()); err != nil {
			return err
		}
	}

	return nil
}

// MultimodalOutput validation

// Validate validates the multimodal output.
func (mo *MultimodalOutput) Validate() error {
	if len(mo.ContentBlocks) == 0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"must have at least one content block", nil)
	}

	// Validate all content blocks
	for i, block := range mo.ContentBlocks {
		if err := block.Validate(); err != nil {
			return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
				fmt.Sprintf("content block %d validation failed", i), err)
		}
	}

	// Validate confidence
	if mo.Confidence < 0.0 || mo.Confidence > 1.0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			fmt.Sprintf("confidence must be between 0.0 and 1.0, got %f", mo.Confidence), nil)
	}

	// Validate provider and model
	if mo.Provider == "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"provider cannot be empty", nil)
	}
	if mo.Model == "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"model cannot be empty", nil)
	}

	return nil
}
