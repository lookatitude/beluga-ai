// Package multimodal provides a unified interface for multimodal model operations.
package multimodal

import (
	"context"
	"fmt"
	"io"
	"mime"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
)

// MultimodalInput represents a multimodal input containing one or more content types.
type MultimodalInput struct {
	CreatedAt     time.Time
	Metadata      map[string]any
	Routing       *RoutingConfig
	ID            string
	Format        string
	ContentBlocks []*ContentBlock
}

// MultimodalOutput represents a multimodal output generated by a model.
type MultimodalOutput struct {
	CreatedAt     time.Time
	Metadata      map[string]any
	ID            string
	InputID       string
	Provider      string
	Model         string
	ContentBlocks []*ContentBlock
	Confidence    float32
}

// ContentBlock represents a single content block within multimodal input/output.
type ContentBlock struct {
	Metadata map[string]any
	Type     string
	URL      string
	FilePath string
	MIMEType string
	Format   string
	Data     []byte
	Size     int64
}

// Content block factory functions

// NewContentBlock creates a new content block from raw data.
// contentType must be one of: "text", "image", "audio", "video".
// The MIME type is automatically detected from the data if not provided.
//
// Parameters:
//   - contentType: Type of content ("text", "image", "audio", "video")
//   - data: Raw content data (bytes)
//
// Returns:
//   - *ContentBlock: A new content block instance
//   - error: Invalid content type or empty data errors
//
// Example:
//
//	block, err := NewContentBlock("text", []byte("Hello, world!"))
//	if err != nil {
//	    log.Fatal(err)
//	}
func NewContentBlock(contentType string, data []byte) (*ContentBlock, error) {
	if contentType == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlock", ErrCodeInvalidInput,
			"content type cannot be empty", nil)
	}

	validTypes := []string{"text", "image", "audio", "video"}
	isValid := false
	for _, t := range validTypes {
		if contentType == t {
			isValid = true
			break
		}
	}
	if !isValid {
		return nil, NewMultimodalErrorWithMessage("NewContentBlock", ErrCodeInvalidInput,
			fmt.Sprintf("invalid content type: %s (must be one of: text, image, audio, video)", contentType), nil)
	}

	block := &ContentBlock{
		Type:     contentType,
		Data:     data,
		Size:     int64(len(data)),
		Metadata: make(map[string]any),
	}

	// Detect MIME type if not provided
	if contentType == "text" {
		block.MIMEType = "text/plain"
	} else {
		// Try to detect MIME type from data
		mimeType := http.DetectContentType(data)
		block.MIMEType = mimeType
	}

	return block, nil
}

// NewContentBlockFromURL creates a new content block from a URL.
// The content is fetched from the URL and the MIME type is determined from the HTTP response headers.
// contentType must be one of: "text", "image", "audio", "video".
//
// Parameters:
//   - ctx: Context for cancellation and timeout control
//   - contentType: Type of content ("text", "image", "audio", "video")
//   - url: URL to fetch content from
//
// Returns:
//   - *ContentBlock: A new content block instance with fetched data
//   - error: Invalid URL, content type, or fetch errors
//
// Example:
//
//	block, err := multimodal.NewContentBlockFromURL(ctx, "image", "https://example.com/image.png")
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// Example usage can be found in examples/multimodal/basic/main.go.
func NewContentBlockFromURL(ctx context.Context, contentType, url string) (*ContentBlock, error) {
	if contentType == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromURL", ErrCodeInvalidInput,
			"content type cannot be empty", nil)
	}
	if url == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromURL", ErrCodeInvalidInput,
			"URL cannot be empty", nil)
	}

	// Fetch the content from URL using a client with timeout
	client := &http.Client{
		Timeout: 30 * time.Second,
	}
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, http.NoBody)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromURL", ErrCodeInvalidInput)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromURL", ErrCodeProviderError)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromURL", ErrCodeProviderError,
			fmt.Sprintf("failed to fetch URL: status %d", resp.StatusCode), nil)
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromURL", ErrCodeProviderError)
	}

	block := &ContentBlock{
		Type:     contentType,
		URL:      url,
		Data:     data,
		Size:     int64(len(data)),
		MIMEType: resp.Header.Get("Content-Type"),
		Metadata: make(map[string]any),
	}

	// Extract format from MIME type or URL
	if block.MIMEType != "" {
		exts, _ := mime.ExtensionsByType(block.MIMEType)
		if len(exts) > 0 {
			block.Format = strings.TrimPrefix(exts[0], ".")
		}
	}

	return block, nil
}

// NewContentBlockFromFile creates a new content block from a file path.
// The file is read and the MIME type is determined from the file extension.
// contentType must be one of: "text", "image", "audio", "video".
//
// Parameters:
//   - ctx: Context for cancellation and timeout control
//   - contentType: Type of content ("text", "image", "audio", "video")
//   - filePath: Path to the file to load
//
// Returns:
//   - *ContentBlock: A new content block instance with file data
//   - error: Invalid file path, content type, or file read errors
//
// Example:
//
//	block, err := multimodal.NewContentBlockFromFile(ctx, "image", "/path/to/image.jpg")
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// Example usage can be found in examples/multimodal/basic/main.go.
func NewContentBlockFromFile(ctx context.Context, contentType, filePath string) (*ContentBlock, error) {
	if contentType == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromFile", ErrCodeInvalidInput,
			"content type cannot be empty", nil)
	}
	if filePath == "" {
		return nil, NewMultimodalErrorWithMessage("NewContentBlockFromFile", ErrCodeInvalidInput,
			"file path cannot be empty", nil)
	}

	// Check if file exists
	info, err := os.Stat(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, NewMultimodalErrorWithMessage("NewContentBlockFromFile", ErrCodeFileNotFound,
				"file not found: "+filePath, err)
		}
		return nil, WrapError(err, "NewContentBlockFromFile", ErrCodeFileNotFound)
	}

	// Read file
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, WrapError(err, "NewContentBlockFromFile", ErrCodeFileNotFound)
	}

	// Detect MIME type from file extension
	ext := strings.ToLower(filepath.Ext(filePath))
	mimeType := mime.TypeByExtension(ext)
	if mimeType == "" {
		mimeType = http.DetectContentType(data)
	}

	block := &ContentBlock{
		Type:     contentType,
		FilePath: filePath,
		Data:     data,
		Size:     info.Size(),
		MIMEType: mimeType,
		Format:   strings.TrimPrefix(ext, "."),
		Metadata: make(map[string]any),
	}

	return block, nil
}

// Validate validates the content block.
func (cb *ContentBlock) Validate() error {
	// Validate type
	validTypes := []string{"text", "image", "audio", "video"}
	isValid := false
	for _, t := range validTypes {
		if cb.Type == t {
			isValid = true
			break
		}
	}
	if !isValid {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"invalid content type: "+cb.Type, nil)
	}

	// Must have at least one data source
	if len(cb.Data) == 0 && cb.URL == "" && cb.FilePath == "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"content block must have at least one of: Data, URL, or FilePath", nil)
	}

	// Validate size
	if cb.Size < 0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"size must be >= 0", nil)
	}

	return nil
}

// MultimodalInputOption defines a function type for MultimodalInput options.
// Options can be used to configure routing, metadata, and format preferences.
type MultimodalInputOption func(*MultimodalInput)

// WithRouting sets the routing configuration for the multimodal input.
// This allows specifying which providers should handle different content types.
//
// Example:
//
//	input, _ := NewMultimodalInput(blocks,
//	    WithRouting(&RoutingConfig{
//	        Strategy:      "manual",
//	        TextProvider:  "openai",
//	        ImageProvider: "gemini",
//	    }),
//	)
func WithRouting(routing *RoutingConfig) MultimodalInputOption {
	return func(input *MultimodalInput) {
		input.Routing = routing
	}
}

// WithMetadata sets additional metadata for the multimodal input.
// Metadata can be used to pass context, user information, or other custom data.
//
// Example:
//
//	input, _ := NewMultimodalInput(blocks,
//	    WithMetadata(map[string]any{
//	        "user_id": "user-123",
//	        "session_id": "session-456",
//	    }),
//	)
func WithMetadata(metadata map[string]any) MultimodalInputOption {
	return func(input *MultimodalInput) {
		if input.Metadata == nil {
			input.Metadata = make(map[string]any)
		}
		for k, v := range metadata {
			input.Metadata[k] = v
		}
	}
}

// WithFormat sets the preferred format for content blocks.
// Format must be one of: "base64", "url", "file_path".
// The normalizer will attempt to convert content blocks to this format.
//
// Example:
//
//	input, _ := NewMultimodalInput(blocks, WithFormat("url"))
func WithFormat(format string) MultimodalInputOption {
	return func(input *MultimodalInput) {
		input.Format = format
	}
}

// NewMultimodalInput creates a new multimodal input with the given content blocks and options.
// At least one content block is required. All content blocks are validated before creating the input.
// Options can be used to configure routing, metadata, and format preferences.
//
// Parameters:
//   - contentBlocks: Slice of content blocks (text, images, audio, video)
//   - opts: Optional configuration functions (WithRouting, WithMetadata, WithFormat)
//
// Returns:
//   - *MultimodalInput: A new multimodal input instance
//   - error: Validation errors if content blocks are empty or invalid
//
// Example:
//
//	textBlock, _ := multimodal.NewContentBlock("text", []byte("Hello"))
//	imageBlock, _ := multimodal.NewContentBlockFromURL(ctx, "image", "https://example.com/image.png")
//	input, err := multimodal.NewMultimodalInput([]*ContentBlock{textBlock, imageBlock})
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// Example usage can be found in examples/multimodal/basic/main.go.
func NewMultimodalInput(contentBlocks []*ContentBlock, opts ...MultimodalInputOption) (*MultimodalInput, error) {
	if len(contentBlocks) == 0 {
		return nil, NewMultimodalErrorWithMessage("NewMultimodalInput", ErrCodeInvalidInput,
			"must have at least one content block", nil)
	}

	// Validate all content blocks
	for i, block := range contentBlocks {
		if err := block.Validate(); err != nil {
			return nil, NewMultimodalErrorWithMessage("NewMultimodalInput", ErrCodeInvalidInput,
				fmt.Sprintf("content block %d validation failed", i), err)
		}
	}

	input := &MultimodalInput{
		ID:            uuid.New().String(),
		ContentBlocks: contentBlocks,
		Metadata:      make(map[string]any),
		Format:        "base64", // default
		CreatedAt:     time.Now(),
	}

	// Apply options
	for _, opt := range opts {
		opt(input)
	}

	// Validate routing if provided
	if input.Routing != nil {
		if err := input.Routing.Validate(context.Background()); err != nil {
			return nil, err
		}
	}

	return input, nil
}

// Validate validates the multimodal input.
func (mi *MultimodalInput) Validate() error {
	if len(mi.ContentBlocks) == 0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"must have at least one content block", nil)
	}

	// Validate all content blocks
	for i, block := range mi.ContentBlocks {
		if err := block.Validate(); err != nil {
			return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
				fmt.Sprintf("content block %d validation failed", i), err)
		}
	}

	// Validate format
	validFormats := []string{"base64", "url", "file_path"}
	isValid := false
	for _, f := range validFormats {
		if mi.Format == f {
			isValid = true
			break
		}
	}
	if !isValid && mi.Format != "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidFormat,
			fmt.Sprintf("invalid format: %s (must be one of: base64, url, file_path)", mi.Format), nil)
	}

	// Validate routing if provided
	if mi.Routing != nil {
		if err := mi.Routing.Validate(context.Background()); err != nil {
			return err
		}
	}

	return nil
}

// MultimodalOutput validation

// Validate validates the multimodal output.
func (mo *MultimodalOutput) Validate() error {
	if len(mo.ContentBlocks) == 0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"must have at least one content block", nil)
	}

	// Validate all content blocks
	for i, block := range mo.ContentBlocks {
		if err := block.Validate(); err != nil {
			return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
				fmt.Sprintf("content block %d validation failed", i), err)
		}
	}

	// Validate confidence
	if mo.Confidence < 0.0 || mo.Confidence > 1.0 {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			fmt.Sprintf("confidence must be between 0.0 and 1.0, got %f", mo.Confidence), nil)
	}

	// Validate provider and model
	if mo.Provider == "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"provider cannot be empty", nil)
	}
	if mo.Model == "" {
		return NewMultimodalErrorWithMessage("Validate", ErrCodeInvalidInput,
			"model cannot be empty", nil)
	}

	return nil
}
