// Package inmemory provides an in-memory implementation of the VectorStore interface.
// This provider is suitable for development, testing, and small-scale applications
// where persistence is not required.
//
// Key Features:
// - Fast in-memory operations
// - Cosine similarity search
// - Thread-safe concurrent access
// - Automatic ID generation
//
// Limitations:
// - Data is lost on restart
// - Memory usage scales linearly with document count
// - Not suitable for large datasets (>100K documents)
//
// Example:
//
//	import "github.com/lookatitude/beluga-ai/pkg/vectorstores/providers/inmemory"
//
//	// Create store
//	store := inmemory.NewInMemoryVectorStore(embedder)
//
//	// Add documents
//	docs := []schema.Document{
//		schema.NewDocument("Machine learning is awesome", map[string]string{"topic": "ml"}),
//	}
//	ids, err := store.AddDocuments(ctx, docs)
//
//	// Search
//	results, scores, err := store.SimilaritySearchByQuery(ctx, "ML basics", 5, embedder)
package inmemory

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"sort"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/lookatitude/beluga-ai/pkg/schema"
)

// Local type definitions to avoid circular dependency
type Embedder interface {
	EmbedDocuments(ctx context.Context, texts []string) ([][]float32, error)
	EmbedQuery(ctx context.Context, text string) ([]float32, error)
}

type Retriever interface {
	GetRelevantDocuments(ctx context.Context, query string) ([]schema.Document, error)
}

type VectorStore interface {
	AddDocuments(ctx context.Context, documents []schema.Document, opts ...Option) ([]string, error)
	DeleteDocuments(ctx context.Context, ids []string, opts ...Option) error
	SimilaritySearch(ctx context.Context, queryVector []float32, k int, opts ...Option) ([]schema.Document, []float32, error)
	SimilaritySearchByQuery(ctx context.Context, query string, k int, embedder Embedder, opts ...Option) ([]schema.Document, []float32, error)
	AsRetriever(opts ...Option) Retriever
	GetName() string
}

type Option func(*Config)

type Config struct {
	Embedder       Embedder
	SearchK        int
	ScoreThreshold float32
}

type MetricsCollector interface {
	RecordDocumentsAdded(ctx context.Context, count int, storeName string)
	RecordDocumentsDeleted(ctx context.Context, count int, storeName string)
	RecordSearch(ctx context.Context, duration time.Duration, resultCount int, storeName string)
	RecordEmbedding(ctx context.Context, duration time.Duration, textCount int, storeName string)
	RecordError(ctx context.Context, errorCode string, storeName string)
}

type VectorStoreError struct {
	Code    string
	Message string
	Cause   error
}

func (e *VectorStoreError) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("%s: %v", e.Message, e.Cause)
	}
	return e.Message
}

func (e *VectorStoreError) Unwrap() error {
	return e.Cause
}

// Error codes
const (
	ErrCodeEmbeddingFailed  = "embedding_failed"
	ErrCodeStorageFailed    = "storage_failed"
	ErrCodeRetrievalFailed  = "retrieval_failed"
	ErrCodeInvalidParameters = "invalid_parameters"
)

func NewVectorStoreError(code, message string, args ...interface{}) *VectorStoreError {
	return &VectorStoreError{
		Code:    code,
		Message: fmt.Sprintf(message, args...),
	}
}

func WrapError(cause error, code, message string, args ...interface{}) *VectorStoreError {
	return &VectorStoreError{
		Code:    code,
		Message: fmt.Sprintf(message, args...),
		Cause:   cause,
	}
}

// Global variables for dependency injection
var (
	globalMetrics *MetricsCollector
)

func SetGlobalMetrics(mc *MetricsCollector) {
	globalMetrics = mc
}

func GetGlobalMetrics() *MetricsCollector {
	return globalMetrics
}

// InMemoryVectorStore is a simple in-memory implementation of the VectorStore interface.
// It stores documents and their embeddings in memory for fast access and similarity search.
type InMemoryVectorStore struct {
	mu         sync.RWMutex
	documents  []schema.Document
	embeddings [][]float32
	embedder   Embedder
	name       string
	nextID     int
}

// storedDoc represents a document with its embedding stored in memory.
type storedDoc struct {
	ID        string
	Document  schema.Document
	Embedding []float32
}

// docWithScore holds a document and its similarity score for search results.
type docWithScore struct {
	Document schema.Document
	Score    float32
}

// NewInMemoryVectorStore creates a new in-memory vector store.
// The embedder parameter is optional but required for text-based operations.
func NewInMemoryVectorStore(embedder Embedder) *InMemoryVectorStore {
	store := &InMemoryVectorStore{
		documents:  make([]schema.Document, 0),
		embeddings: make([][]float32, 0),
		embedder:   embedder,
		name:       "inmemory",
		nextID:     1,
	}

	// Log store creation
	// Logging disabled to avoid circular dependency(context.Background(), "InMemory vector store created", store.name)

	return store
}

// NewInMemoryVectorStoreFromConfig creates a new in-memory store from configuration.
// This is used by the factory pattern.
func NewInMemoryVectorStoreFromConfig(ctx context.Context, config Config) (VectorStore, error) {
	store := NewInMemoryVectorStore(config.Embedder)

	// Logging disabled to avoid circular dependency

	return store, nil
}

// Provider registration is handled externally to avoid circular dependencies

// AddDocuments adds documents to the vector store with observability and proper error handling.
func (s *InMemoryVectorStore) AddDocuments(ctx context.Context, documents []schema.Document, opts ...Option) ([]string, error) {
	startTime := time.Now()

	// Apply options
	config := NewDefaultConfig()
	ApplyOptions(config, opts...)

	// Start tracing span
	ctx, spanEnd := GetGlobalTracer().StartAddDocumentsSpan(ctx, s.name, len(documents))
	defer spanEnd()

	// Use embedder from options or stored embedder
	embedder := config.Embedder
	if embedder == nil {
		embedder = s.embedder
	}

	if embedder == nil && len(documents) > 0 && documents[0].Embedding == nil {
		err := NewVectorStoreError(ErrCodeEmbeddingFailed,
			"embedder is required if documents do not have pre-computed embeddings")
		if mc := GetGlobalMetrics(); mc != nil {
			mc.RecordError(ctx, ErrCodeEmbeddingFailed, s.name)
		}
		return nil, err
	}

	// Generate embeddings if needed
	textsToEmbed := make([]string, 0, len(documents))
	docIndices := make([]int, 0, len(documents))

	for i, doc := range documents {
		if doc.Embedding == nil || len(doc.Embedding) == 0 {
			textsToEmbed = append(textsToEmbed, doc.GetContent())
			docIndices = append(docIndices, i)
		}
	}

	// Embed documents that need embedding
	var embeddings [][]float32
	if len(textsToEmbed) > 0 {
		embedStart := time.Now()
		embeds, err := embedder.EmbedDocuments(ctx, textsToEmbed)
		if err != nil {
			err = WrapError(err, ErrCodeEmbeddingFailed, "failed to embed documents")
			if mc := GetGlobalMetrics(); mc != nil {
				mc.RecordError(ctx, ErrCodeEmbeddingFailed, s.name)
			}
			return nil, err
		}
		if mc := GetGlobalMetrics(); mc != nil {
			mc.RecordEmbedding(ctx, time.Since(embedStart), len(textsToEmbed), s.name)
		}
		embeddings = embeds
	}

	// Store documents
	s.mu.Lock()
	defer s.mu.Unlock()

	ids := make([]string, len(documents))
	embedIndex := 0

	for i, doc := range documents {
		var embedding []float32
		if doc.Embedding != nil && len(doc.Embedding) > 0 {
			embedding = doc.Embedding
		} else {
			embedding = embeddings[embedIndex]
			embedIndex++
		}

		// Generate ID
		id := uuid.New().String()
		ids[i] = id

		// Create a copy of the document with the generated ID
		docWithID := schema.NewDocument(doc.GetContent(), doc.Metadata)
		docWithID.ID = id

		s.documents = append(s.documents, docWithID)
		s.embeddings = append(s.embeddings, embedding)
	}

	// Record metrics and log success
	duration := time.Since(startTime)
	if mc := GetGlobalMetrics(); mc != nil {
		mc.RecordDocumentsAdded(ctx, len(documents), s.name)
	}
	// Skip logging to avoid circular dependency - can be added back with proper dependency injection

	return ids, nil
}

// SimilaritySearch performs similarity search using a pre-computed query vector.
func (s *InMemoryVectorStore) SimilaritySearch(ctx context.Context, queryVector []float32, k int, opts ...Option) ([]schema.Document, []float32, error) {
	startTime := time.Now()

	// Apply options
	config := NewDefaultConfig()
	ApplyOptions(config, opts...)

	// Start tracing span
	ctx, spanEnd := GetGlobalTracer().StartSearchSpan(ctx, s.name, 0, k)
	defer spanEnd()

	s.mu.RLock()
	defer s.mu.RUnlock()

	if len(s.documents) == 0 {
		LogDebug(ctx, "No documents in store", s.name)
		return []schema.Document{}, []float32{}, nil
	}

	if k <= 0 {
		err := NewVectorStoreError(ErrCodeInvalidParameters, "k must be greater than 0")
		GetGlobalMetrics().RecordError(ctx, ErrCodeInvalidParameters, s.name)
		// Logging disabled to avoid circular dependency(ctx, err, "SimilaritySearch", s.name)
		return nil, nil, err
	}

	// Calculate similarities
	results := make([]docWithScore, 0, len(s.documents))
	for i, emb := range s.embeddings {
		score, err := s.cosineSimilarity(queryVector, emb)
		if err != nil {
			err = WrapError(err, ErrCodeRetrievalFailed, "failed to calculate similarity for document %d", i)
			GetGlobalMetrics().RecordError(ctx, ErrCodeRetrievalFailed, s.name)
			// Logging disabled to avoid circular dependency(ctx, err, "SimilaritySearch", s.name)
			return nil, nil, err
		}

		if score >= config.ScoreThreshold {
			results = append(results, docWithScore{
				Document: s.documents[i],
				Score:    score,
			})
		}
	}

	// Sort by score (descending)
	sort.Slice(results, func(i, j int) bool {
		return results[i].Score > results[j].Score
	})

	// Limit results
	numResults := k
	if len(results) < k {
		numResults = len(results)
	}

	resultDocs := make([]schema.Document, numResults)
	resultScores := make([]float32, numResults)
	for i := 0; i < numResults; i++ {
		resultDocs[i] = results[i].Document
		resultScores[i] = results[i].Score
	}

	// Record metrics and log
	duration := time.Since(startTime)
	GetGlobalMetrics().RecordSearch(ctx, duration, numResults, s.name)
	// Logging disabled to avoid circular dependency(ctx, slog.LevelInfo, s.name, 0, k, numResults, duration, nil)

	return resultDocs, resultScores, nil
}

// SimilaritySearchByQuery performs similarity search using a text query.
func (s *InMemoryVectorStore) SimilaritySearchByQuery(ctx context.Context, query string, k int, embedder Embedder, opts ...Option) ([]schema.Document, []float32, error) {
	startTime := time.Now()

	// Apply options
	config := NewDefaultConfig()
	ApplyOptions(config, opts...)

	// Start tracing span
	ctx, spanEnd := GetGlobalTracer().StartSearchSpan(ctx, s.name, len(query), k)
	defer spanEnd()

	// Use embedder from options or stored embedder
	currentEmbedder := embedder
	if currentEmbedder == nil {
		currentEmbedder = s.embedder
	}
	if currentEmbedder == nil {
		err := NewVectorStoreError(ErrCodeEmbeddingFailed, "embedder is required for SimilaritySearchByQuery")
		GetGlobalMetrics().RecordError(ctx, ErrCodeEmbeddingFailed, s.name)
		// Logging disabled to avoid circular dependency(ctx, err, "SimilaritySearchByQuery", s.name)
		return nil, nil, err
	}

	// Generate query embedding
	embedStart := time.Now()
	queryEmbedding, err := currentEmbedder.EmbedQuery(ctx, query)
	if err != nil {
		err = WrapError(err, ErrCodeEmbeddingFailed, "failed to embed query")
		GetGlobalMetrics().RecordError(ctx, ErrCodeEmbeddingFailed, s.name)
		// Logging disabled to avoid circular dependency(ctx, err, "SimilaritySearchByQuery", s.name)
		return nil, nil, err
	}
	GetGlobalMetrics().RecordEmbedding(ctx, time.Since(embedStart), 1, s.name)

	// Perform similarity search
	results, scores, err := s.SimilaritySearch(ctx, queryEmbedding, k, opts...)
	if err != nil {
		return nil, nil, err
	}

	// Log success
	duration := time.Since(startTime)
	// Logging disabled to avoid circular dependency(ctx, slog.LevelInfo, s.name, len(query), k, len(results), duration, nil)

	return results, scores, nil
}

// DeleteDocuments removes documents from the store based on their IDs.
func (s *InMemoryVectorStore) DeleteDocuments(ctx context.Context, ids []string, opts ...Option) error {
	startTime := time.Now()

	// Start tracing span
	ctx, spanEnd := GetGlobalTracer().StartDeleteDocumentsSpan(ctx, s.name, len(ids))
	defer spanEnd()

	s.mu.Lock()
	defer s.mu.Unlock()

	// Create set of IDs to delete for efficient lookup
	idSet := make(map[string]bool)
	for _, id := range ids {
		idSet[id] = true
	}

	// Filter documents
	var newDocuments []schema.Document
	var newEmbeddings [][]float32
	deletedCount := 0

	for i, doc := range s.documents {
		if !idSet[doc.ID] {
			newDocuments = append(newDocuments, doc)
			newEmbeddings = append(newEmbeddings, s.embeddings[i])
		} else {
			deletedCount++
		}
	}

	s.documents = newDocuments
	s.embeddings = newEmbeddings

	// Record metrics and log
	duration := time.Since(startTime)
	GetGlobalMetrics().RecordDocumentsDeleted(ctx, deletedCount, s.name)
	// Logging disabled to avoid circular dependency(ctx, slog.LevelInfo, "delete_documents", s.name, deletedCount, duration, nil)

	return nil
}

// AsRetriever returns a Retriever instance based on this VectorStore.
func (s *InMemoryVectorStore) AsRetriever(opts ...Option) Retriever {
	return &InMemoryRetriever{
		store: s,
		opts:  opts,
	}
}

// GetName returns the name of the vector store.
func (s *InMemoryVectorStore) GetName() string {
	return s.name
}

// cosineSimilarity calculates cosine similarity between two vectors.
func (s *InMemoryVectorStore) cosineSimilarity(a, b []float32) (float32, error) {
	if len(a) != len(b) {
		return 0, fmt.Errorf("vectors have different lengths: %d vs %d", len(a), len(b))
	}
	if len(a) == 0 {
		return 0, fmt.Errorf("vectors are empty")
	}

	var dotProduct float32
	var normA float32
	var normB float32

	for i := 0; i < len(a); i++ {
		dotProduct += a[i] * b[i]
		normA += a[i] * a[i]
		normB += b[i] * b[i]
	}

	if normA == 0 || normB == 0 {
		return 0, fmt.Errorf("cannot compute cosine similarity with zero vector")
	}

	return float32(float64(dotProduct) / (math.Sqrt(float64(normA)) * math.Sqrt(float64(normB)))), nil
}

// InMemoryRetriever implements the Retriever interface for InMemoryVectorStore.
type InMemoryRetriever struct {
	store *InMemoryVectorStore
	opts  []Option
}

// GetRelevantDocuments retrieves relevant documents for a query.
func (r *InMemoryRetriever) GetRelevantDocuments(ctx context.Context, query string) ([]schema.Document, error) {
	// Apply default search options
	opts := append(r.opts, WithSearchK(5))

	docs, _, err := r.store.SimilaritySearchByQuery(ctx, query, 5, nil, opts...)
	return docs, err
}

// Ensure InMemoryVectorStore implements the VectorStore interface.
var _ VectorStore = (*InMemoryVectorStore)(nil)

// Ensure InMemoryRetriever implements the Retriever interface.
var _ Retriever = (*InMemoryRetriever)(nil)
