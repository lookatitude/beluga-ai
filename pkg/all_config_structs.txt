File: ./schema/agent_config.go
package schema

// AgentConfig defines the configuration for an agent.
// This can include settings for the LLM, tools, memory, and other agent-specific parameters.
type AgentConfig struct {
	Name string `yaml:"name" json:"name"` // Unique name for this agent configuration

	// LLMProviderName specifies the name of the LLMProviderConfig to use for this agent.
	// This should correspond to a name defined in the LLM provider configurations.
	LLMProviderName string `yaml:"llm_provider_name" json:"llm_provider_name"`

	// LLMProviderConfigName is an alias or specific field for the LLM provider config name.
	// It seems the factory was expecting this exact name.
	LLMProviderConfigName string `yaml:"llm_provider_config_name,omitempty" json:"llm_provider_config_name,omitempty"`

	// ToolNames lists the names of the tools available to this agent.
	// These names should correspond to tool configurations.
	ToolNames []string `yaml:"tool_names,omitempty" json:"tool_names,omitempty"`

	// MemoryProviderName specifies the name of the MemoryProviderConfig to use for this agent.
	// This should correspond to a name defined in the memory provider configurations.
	MemoryProviderName string `yaml:"memory_provider_name,omitempty" json:"memory_provider_name,omitempty"`

	// MemoryType specifies the type of memory to use (e.g., "buffer", "vector").
	MemoryType string `yaml:"memory_type,omitempty" json:"memory_type,omitempty"`

	// MemoryConfigName specifies the name of the specific memory configuration to use.
	// This would correspond to a named configuration within the memory provider settings.
	MemoryConfigName string `yaml:"memory_config_name,omitempty" json:"memory_config_name,omitempty"`

	// MaxIterations defines the maximum number of steps the agent can take before stopping.
	// This is a safety measure to prevent infinite loops.
	MaxIterations int `yaml:"max_iterations,omitempty" json:"max_iterations,omitempty"`

	// PromptTemplate is the main prompt template used by the agent.
	// It can be a string or a path to a template file.
	PromptTemplate string `yaml:"prompt_template,omitempty" json:"prompt_template,omitempty"`

	// OutputParser defines how the agent's output is parsed.
	// This could be the name of a registered output parser or configuration for one.
	OutputParser string `yaml:"output_parser,omitempty" json:"output_parser,omitempty"`

	// AgentType specifies the type of agent (e.g., "react", "openai_tools").
	AgentType string `yaml:"agent_type,omitempty" json:"agent_type,omitempty"`

	// Additional agent-specific configuration can be added here or in a map.
	// For example, specific settings for a ReAct agent or an OpenAI tools agent.
	AgentSpecificConfig map[string]interface{} `yaml:"agent_specific_config,omitempty" json:"agent_specific_config,omitempty"`
}

File: ./schema/llm_provider_config.go
package schema

// LLMProviderConfig defines the configuration for a specific LLM provider instance.
// It allows for common parameters and a flexible way to include provider-specific settings.
type LLMProviderConfig struct {
	Name string `yaml:"name" json:"name"` // Unique name for this configuration instance (e.g., "openai_gpt4_turbo", "anthropic_claude3_opus")
	// Provider identifies the type of LLM provider (e.g., "openai", "anthropic", "gemini", "ollama").
	// This will be used by the LLMProviderFactory to instantiate the correct client.
	Provider string `yaml:"provider" json:"provider"`

	// ModelName specifies the exact model to be used (e.g., "gpt-4-turbo-preview", "claude-3-opus-20240229").
	ModelName string `yaml:"model_name" json:"model_name"`

	// APIKey is the API key for the LLM provider, if required.
	// It is recommended to manage this securely, e.g., via environment variables or a secrets manager,
	// and have the configuration loader resolve it.
	APIKey string `yaml:"api_key,omitempty" json:"api_key,omitempty"`

	// BaseURL can be used to specify a custom API endpoint, e.g., for self-hosted models or proxies.
	BaseURL string `yaml:"base_url,omitempty" json:"base_url,omitempty"`

	// DefaultCallOptions holds common LLM call parameters that can be overridden at runtime.
	DefaultCallOptions map[string]interface{} `yaml:"default_call_options,omitempty" json:"default_call_options,omitempty"`
	// Example DefaultCallOptions:
	// "temperature": 0.7
	// "max_tokens": 1024
	// "top_p": 1.0

	// ProviderSpecific holds any additional configuration parameters unique to the LLM provider.
	// This allows for flexibility in supporting diverse provider APIs without cluttering the main struct.
	// For example, for Ollama, this might include "keep_alive" or "num_ctx".
	// For OpenAI, it might include "organization_id".
	ProviderSpecific map[string]interface{} `yaml:"provider_specific,omitempty" json:"provider_specific,omitempty"`
}




// LLMOption defines a function type for LLM call options.
// It allows for flexible configuration of LLM calls.
type LLMOption func(options *CallOptions)

// CallOptions holds parameters for an LLM call.
// This struct can be expanded with more common options.
type CallOptions struct {
	Temperature      *float64
	MaxTokens        *int
	TopP             *float64
	FrequencyPenalty *float64
	PresencePenalty  *float64
	Stop             []string
	Streaming        bool
	// ProviderSpecificArgs allows for passing through any other provider-specific options.
	ProviderSpecificArgs map[string]interface{}
}

// NewCallOptions creates a new CallOptions with default values.
func NewCallOptions() *CallOptions {
	return &CallOptions{
		ProviderSpecificArgs: make(map[string]interface{}),
	}
}

// WithTemperature sets the temperature for the LLM call.
func WithTemperature(temp float64) LLMOption {
	return func(o *CallOptions) {
		o.Temperature = &temp
	}
}

// WithMaxTokens sets the max tokens for the LLM call.
func WithMaxTokens(maxTokens int) LLMOption {
	return func(o *CallOptions) {
		o.MaxTokens = &maxTokens
	}
}

// WithTopP sets the TopP for the LLM call.
func WithTopP(topP float64) LLMOption {
	return func(o *CallOptions) {
		o.TopP = &topP
	}
}

// WithFrequencyPenalty sets the frequency penalty for the LLM call.
func WithFrequencyPenalty(penalty float64) LLMOption {
	return func(o *CallOptions) {
		o.FrequencyPenalty = &penalty
	}
}

// WithPresencePenalty sets the presence penalty for the LLM call.
func WithPresencePenalty(penalty float64) LLMOption {
	return func(o *CallOptions) {
		o.PresencePenalty = &penalty
	}
}

// WithStopSequences sets the stop sequences for the LLM call.
func WithStopSequences(stop []string) LLMOption {
	return func(o *CallOptions) {
		o.Stop = stop
	}
}

// WithStreaming enables or disables streaming for the LLM call.
func WithStreaming(streaming bool) LLMOption {
	return func(o *CallOptions) {
		o.Streaming = streaming
	}
}

// WithProviderSpecificArg adds a provider-specific argument.
func WithProviderSpecificArg(key string, value interface{}) LLMOption {
	return func(o *CallOptions) {
		if o.ProviderSpecificArgs == nil {
			o.ProviderSpecificArgs = make(map[string]interface{})
		}
		o.ProviderSpecificArgs[key] = value
	}
}

File: ./schema/embedding_provider_config.go
package schema

// EmbeddingProviderConfig defines the configuration for a specific embedding provider instance.
type EmbeddingProviderConfig struct {
	Name      string `yaml:"name" json:"name" mapstructure:"name"`
	Provider  string `yaml:"provider" json:"provider" mapstructure:"provider"`
	ModelName string `yaml:"model_name" json:"model_name" mapstructure:"model_name"`
	APIKey    string `yaml:"api_key" json:"api_key" mapstructure:"api_key"`
	BaseURL   string `yaml:"base_url,omitempty" json:"base_url,omitempty" mapstructure:"base_url,omitempty"`
	ProviderSpecific map[string]interface{} `yaml:"provider_specific,omitempty" json:"provider_specific,omitempty" mapstructure:"provider_specific,omitempty"`
}

File: ./schema/vectorstore_config.go
package schema

// VectorStoreConfig defines the configuration for a vector store provider.
type VectorStoreConfig struct {
	Name             string                 `mapstructure:"name" yaml:"name"`                         // Unique name for this vector store configuration
	Provider         string                 `mapstructure:"provider" yaml:"provider"`                   // e.g., "inmemory", "pgvector", "pinecone"
	ConnectionString string                 `mapstructure:"connection_string,omitempty" yaml:"connection_string,omitempty"` // Optional: Connection string if applicable
	ProviderSpecific map[string]interface{} `mapstructure:"provider_specific,omitempty" yaml:"provider_specific,omitempty"` // Provider-specific settings
}

File: ./agents/config/config_manager.go
package config

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v2"
)

// AgentConfig represents the configuration for a single agent.
type AgentConfig struct {
	Type         string                 `json:"type" yaml:"type"`
	Name         string                 `json:"name" yaml:"name"`
	Role         string                 `json:"role" yaml:"role"`
	Settings     map[string]interface{} `json:"settings" yaml:"settings"`
	MaxRetries   int                    `json:"max_retries" yaml:"max_retries"`
	RetryDelay   int                    `json:"retry_delay" yaml:"retry_delay"`
	Dependencies []string               `json:"dependencies" yaml:"dependencies"`
	Description  string                 `json:"description" yaml:"description"`
}

// AgentConfigMap maps agent names to their configurations.
type AgentConfigMap map[string]*AgentConfig

// AgentModuleConfig represents the configuration for the entire agent module.
type AgentModuleConfig struct {
	Agents            []*AgentConfig      `json:"agents" yaml:"agents"`
	DefaultSettings   map[string]interface{} `json:"default_settings" yaml:"default_settings"`
	LoggingConfig     map[string]interface{} `json:"logging" yaml:"logging"`
	HealthCheckConfig map[string]interface{} `json:"health_check" yaml:"health_check"`
	WorkflowConfig    map[string]interface{} `json:"workflow" yaml:"workflow"`
}

// ConfigManager handles loading and accessing agent configurations.
type ConfigManager struct {
	config          *AgentModuleConfig
	agentConfigMap  AgentConfigMap
	envVarOverrides map[string]string
	configPath      string
}

// NewConfigManager creates a new configuration manager instance.
func NewConfigManager() *ConfigManager {
	return &ConfigManager{
		config:          &AgentModuleConfig{},
		agentConfigMap:  make(AgentConfigMap),
		envVarOverrides: make(map[string]string),
	}
}

// LoadConfig loads agent configuration from a JSON or YAML file.
func (cm *ConfigManager) LoadConfig(filePath string) error {
	// Read the file
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	// Determine file type and parse
	var config AgentModuleConfig
	ext := strings.ToLower(filepath.Ext(filePath))

	switch ext {
	case ".json":
		if err := json.Unmarshal(data, &config); err != nil {
			return fmt.Errorf("failed to parse JSON config: %w", err)
		}
	case ".yaml", ".yml":
		if err := yaml.Unmarshal(data, &config); err != nil {
			return fmt.Errorf("failed to parse YAML config: %w", err)
		}
	default:
		return fmt.Errorf("unsupported config file format: %s", ext)
	}

	// Store the config
	cm.config = &config
	cm.configPath = filePath

	// Build the agent config map for easy lookups
	for _, agent := range config.Agents {
		cm.agentConfigMap[agent.Name] = agent
	}

	// Load environment variable overrides
	cm.loadEnvVarOverrides()

	return nil
}

// loadEnvVarOverrides loads configuration overrides from environment variables.
// The format is BELUGA_AGENT_[AGENT_NAME]_[SETTING]
func (cm *ConfigManager) loadEnvVarOverrides() {
	for _, env := range os.Environ() {
		parts := strings.SplitN(env, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key, value := parts[0], parts[1]
		if !strings.HasPrefix(key, "BELUGA_AGENT_") {
			continue
		}

		// Strip the prefix
		key = strings.TrimPrefix(key, "BELUGA_AGENT_")
		parts = strings.Split(key, "_")

		if len(parts) < 2 {
			continue
		}

		// Extract agent name and setting name
		agentName := parts[0]
		settingName := strings.Join(parts[1:], "_")

		cm.envVarOverrides[agentName+"_"+settingName] = value
	}
}

// GetAgentConfig retrieves the configuration for a specific agent.
func (cm *ConfigManager) GetAgentConfig(agentName string) (*AgentConfig, error) {
	config, exists := cm.agentConfigMap[agentName]
	if !exists {
		return nil, fmt.Errorf("configuration for agent %s not found", agentName)
	}

	// Create a copy to avoid modifying the original
	configCopy := *config

	// Apply environment variable overrides
	for key, value := range cm.envVarOverrides {
		parts := strings.SplitN(key, "_", 2)
		if len(parts) == 2 && parts[0] == agentName {
			settingName := parts[1]
			
			// Handle different settings
			switch settingName {
			case "MAX_RETRIES":
				if val, err := parseInt(value); err == nil {
					configCopy.MaxRetries = val
				}
			case "RETRY_DELAY":
				if val, err := parseInt(value); err == nil {
					configCopy.RetryDelay = val
				}
			case "TYPE":
				configCopy.Type = value
			case "ROLE":
				configCopy.Role = value
			default:
				// For other settings, add to the settings map
				if configCopy.Settings == nil {
					configCopy.Settings = make(map[string]interface{})
				}
				configCopy.Settings[strings.ToLower(settingName)] = value
			}
		}
	}

	return &configCopy, nil
}

// GetAllAgentConfigs returns a slice of all agent configurations.
func (cm *ConfigManager) GetAllAgentConfigs() []*AgentConfig {
	configs := make([]*AgentConfig, len(cm.config.Agents))
	for i, agent := range cm.config.Agents {
		// Apply any overrides
		config, _ := cm.GetAgentConfig(agent.Name)
		configs[i] = config
	}
	return configs
}

// GetDefaultSettings returns the default settings for all agents.
func (cm *ConfigManager) GetDefaultSettings() map[string]interface{} {
	// Return a copy to prevent modification of the original
	settings := make(map[string]interface{})
	for k, v := range cm.config.DefaultSettings {
		settings[k] = v
	}
	return settings
}

// GetLoggingConfig returns the logging configuration.
func (cm *ConfigManager) GetLoggingConfig() map[string]interface{} {
	// Return a copy to prevent modification of the original
	config := make(map[string]interface{})
	for k, v := range cm.config.LoggingConfig {
		config[k] = v
	}
	return config
}

// GetHealthCheckConfig returns the health check configuration.
func (cm *ConfigManager) GetHealthCheckConfig() map[string]interface{} {
	// Return a copy to prevent modification of the original
	config := make(map[string]interface{})
	for k, v := range cm.config.HealthCheckConfig {
		config[k] = v
	}
	return config
}

// SaveConfig saves the current configuration to a file.
func (cm *ConfigManager) SaveConfig(filePath string) error {
	if filePath == "" {
		filePath = cm.configPath
	}
	
	if filePath == "" {
		return fmt.Errorf("no file path provided and no previous config file loaded")
	}

	// Determine file format based on extension
	var data []byte
	var err error
	
	ext := strings.ToLower(filepath.Ext(filePath))
	switch ext {
	case ".json":
		data, err = json.MarshalIndent(cm.config, "", "  ")
	case ".yaml", ".yml":
		data, err = yaml.Marshal(cm.config)
	default:
		return fmt.Errorf("unsupported config file format: %s", ext)
	}
	
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Create directory if it doesn't exist
	dir := filepath.Dir(filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write to file
	if err := ioutil.WriteFile(filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// Helper function to parse an integer from a string
func parseInt(s string) (int, error) {
	var i int
	_, err := fmt.Sscanf(s, "%d", &i)
	return i, err
}File: ./agents/factory.go
package agents

import (
	"github.com/lookatitude/beluga-ai/pkg/interfaces"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"time"
)

// AgentConfig represents the configuration structure for an agent.
type AgentConfig struct {
	Type           string                 `json:"type"`
	Name           string                 `json:"name"`
	Role           string                 `json:"role"`
	Settings       map[string]interface{} `json:"settings"`
	MaxRetries     int                    `json:"max_retries"`
	RetryDelay     int                    `json:"retry_delay"`
	Dependencies   []string               `json:"dependencies"`
	Description    string                 `json:"description"`
}

// AgentRegistry maintains a registry of all created agents for reference and management.
type AgentRegistry struct {
	Agents map[string]interfaces.Agent
}

// NewAgentRegistry creates a new AgentRegistry.
func NewAgentRegistry() *AgentRegistry {
	return &AgentRegistry{
		Agents: make(map[string]interfaces.Agent),
	}
}

// RegisterAgent adds an agent to the registry.
func (r *AgentRegistry) RegisterAgent(name string, agent interfaces.Agent) {
	r.Agents[name] = agent
}

// GetAgent retrieves an agent from the registry by name.
func (r *AgentRegistry) GetAgent(name string) (interfaces.Agent, bool) {
	agent, exists := r.Agents[name]
	return agent, exists
}

// ListAgents returns a list of all registered agent names.
func (r *AgentRegistry) ListAgents() []string {
	agentNames := make([]string, 0, len(r.Agents))
	for name := range r.Agents {
		agentNames = append(agentNames, name)
	}
	return agentNames
}

// AgentFactory is responsible for creating agents dynamically.
type AgentFactory struct {
	Registry *AgentRegistry
}

// NewAgentFactory creates and returns a new instance of AgentFactory.
func NewAgentFactory() *AgentFactory {
	return &AgentFactory{
		Registry: NewAgentRegistry(),
	}
}

// CreateAgentFromConfig creates an agent based on the provided configuration.
func (f *AgentFactory) CreateAgentFromConfig(config *AgentConfig) (interfaces.Agent, error) {
	agent, err := f.CreateAgent(config.Type, config.Name, config.Settings)
	if err != nil {
		return nil, err
	}
	
	// Register the agent
	f.Registry.RegisterAgent(config.Name, agent)
	return agent, nil
}

// CreateAgent creates an agent based on the provided type and name.
func (f *AgentFactory) CreateAgent(agentType, name string, config map[string]interface{}) (interfaces.Agent, error) {
	var agent interfaces.Agent
	
	switch agentType {
	case "DataFetcherAgent":
		dataSource := getStringParam(config, "data_source", "default")
		dataFormat := getStringParam(config, "data_format", "json")
		
		dataFetcher := NewDataFetcherAgent(name, dataSource, dataFormat)
		if err := dataFetcher.Initialize(config); err != nil {
			return nil, fmt.Errorf("failed to initialize DataFetcherAgent: %w", err)
		}
		agent = dataFetcher
		
	case "AnalyzerAgent":
		analysisType := getStringParam(config, "analysis_type", "basic")
		
		analyzer := NewAnalyzerAgent(name, analysisType)
		if err := analyzer.Initialize(config); err != nil {
			return nil, fmt.Errorf("failed to initialize AnalyzerAgent: %w", err)
		}
		agent = analyzer
		
	case "DecisionMakerAgent":
		decisionMaker := NewDecisionMakerAgent(name)
		if err := decisionMaker.Initialize(config); err != nil {
			return nil, fmt.Errorf("failed to initialize DecisionMakerAgent: %w", err)
		}
		agent = decisionMaker
		
	case "ExecutorAgent":
		action := getStringParam(config, "action", "default_action")
		target := getStringParam(config, "target", "default_target")
		
		executor := NewExecutorAgent(name, action, target)
		if err := executor.Initialize(config); err != nil {
			return nil, fmt.Errorf("failed to initialize ExecutorAgent: %w", err)
		}
		agent = executor
		
	case "MonitorAgent":
		interval := time.Duration(getIntParam(config, "interval_seconds", 60)) * time.Second
		
		monitor := NewMonitorAgent(name, interval)
		if err := monitor.Initialize(config); err != nil {
			return nil, fmt.Errorf("failed to initialize MonitorAgent: %w", err)
		}
		
		// Add monitor targets if specified
		if targets, ok := config["monitor_targets"].([]interface{}); ok {
			for _, target := range targets {
				if targetStr, ok := target.(string); ok {
					monitor.AddMonitorTarget(targetStr)
				}
			}
		}
		
		agent = monitor
		
	default:
		return nil, fmt.Errorf("unknown agent type: %s", agentType)
	}
	
	// Register the created agent
	f.Registry.RegisterAgent(name, agent)
	
	return agent, nil
}

// LoadAgentsFromConfig loads and creates agents from a configuration file.
func (f *AgentFactory) LoadAgentsFromConfig(configPath string) ([]interfaces.Agent, error) {
	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read agent config file: %w", err)
	}
	
	var configs []AgentConfig
	if err := json.Unmarshal(data, &configs); err != nil {
		return nil, fmt.Errorf("failed to parse agent config JSON: %w", err)
	}
	
	agents := make([]interfaces.Agent, 0, len(configs))
	for _, config := range configs {
		agent, err := f.CreateAgentFromConfig(&config)
		if err != nil {
			return nil, fmt.Errorf("failed to create agent from config: %w", err)
		}
		agents = append(agents, agent)
	}
	
	return agents, nil
}

// LoadAgentsFromDirectory loads and creates agents from all config files in a directory.
func (f *AgentFactory) LoadAgentsFromDirectory(dirPath string) ([]interfaces.Agent, error) {
	files, err := ioutil.ReadDir(dirPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory: %w", err)
	}
	
	var agents []interfaces.Agent
	for _, file := range files {
		if file.IsDir() {
			continue
		}
		
		ext := filepath.Ext(file.Name())
		if ext != ".json" && ext != ".yaml" && ext != ".yml" {
			continue
		}
		
		path := filepath.Join(dirPath, file.Name())
		agentsFromFile, err := f.LoadAgentsFromConfig(path)
		if err != nil {
			return nil, fmt.Errorf("failed to load agents from %s: %w", path, err)
		}
		
		agents = append(agents, agentsFromFile...)
	}
	
	return agents, nil
}

// Helper functions for parameter extraction
func getStringParam(config map[string]interface{}, key, defaultValue string) string {
	if val, ok := config[key].(string); ok {
		return val
	}
	return defaultValue
}

func getIntParam(config map[string]interface{}, key string, defaultValue int) int {
	if val, ok := config[key].(float64); ok {
		return int(val)
	}
	if val, ok := config[key].(int); ok {
		return val
	}
	return defaultValue
}File: ./embeddings/factory.go
package embeddings

import (
	"fmt"

	"github.com/lookatitude/beluga-ai/pkg/config"
	"github.com/lookatitude/beluga-ai/pkg/embeddings/iface" // Import the new interface package
)

const (
	ProviderMock   = "mock"
	ProviderOpenAI = "openai"
)

// EmbedderFactoryConfig defines the overall configuration for selecting an embedder provider.
// It will be part of the main application configuration.
type EmbedderFactoryConfig struct {
	Provider string `mapstructure:"provider"` // e.g., "mock", "openai"
}

// EmbedderConstructor defines the function signature for creating an embedder instance.
// It takes the global ViperProvider to allow unmarshalling of specific configurations.
type EmbedderConstructor func(appConfig *config.ViperProvider) (iface.Embedder, error)

var embedderRegistry = make(map[string]EmbedderConstructor)

// RegisterEmbedderProvider allows embedder providers to register their constructor functions.
// This is typically called from the init() function of each provider package.
func RegisterEmbedderProvider(name string, constructor EmbedderConstructor) {
	if _, exists := embedderRegistry[name]; exists {
		// Optionally, log a warning or panic if a provider is registered multiple times.
		// For simplicity, we might allow overriding, or panic as shown here.
		panic(fmt.Sprintf("Embedder provider %s already registered", name))
	}
	embedderRegistry[name] = constructor
}

// NewEmbedderProvider function removed from this file to resolve redeclaration error.
// The canonical version is in pkg/embeddings/provider.go

File: ./vectorstores/pgvector/pgvector_store.go
package pgvector

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"

	"github.com/lookatitude/beluga-ai/pkg/embeddings/iface"
	"github.com/lookatitude/beluga-ai/pkg/schema"
	"github.com/lookatitude/beluga-ai/pkg/vectorstores"

	_ "github.com/lib/pq" // PostgreSQL driver
	// Placeholder for actual pgvector library if one is used, e.g., github.com/pgvector/pgvector-go
	// For now, we assume direct SQL interaction or a helper library for pgvector operations.
)

// PgVectorStore implements the VectorStore interface using a PostgreSQL database
// with the pgvector extension.
type PgVectorStore struct {
	db             *sql.DB
	tableName      string
	embeddingDim   int    // Dimension of the embeddings
	collectionName string // Optional, for multi-tenancy or logical separation within the table
	name           string
	// Other necessary fields like connection string, preDeleteCollection, etc.
}

// PgVectorStoreConfig holds configuration specific to PgVectorStore.
type PgVectorStoreConfig struct {
	ConnectionString    string `mapstructure:"connection_string"`
	TableName           string `mapstructure:"table_name"`
	EmbeddingDimension  int    `mapstructure:"embedding_dimension"`
	CollectionName      string `mapstructure:"collection_name"`         // Optional
	PreDeleteCollection bool   `mapstructure:"pre_delete_collection"` // If true, deletes existing data for the collection on init
}

// NewPgVectorStore creates a new PgVectorStore.
// It requires a database connection string, table name, and embedding dimension.
// Further configuration can be passed via PgVectorStoreConfig within vectorstores.Config.ProviderArgs.
func NewPgVectorStore(ctx context.Context, config vectorstores.Config) (*PgVectorStore, error) {
	providerArgs, ok := config.ProviderArgs["pgvector"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("pgvector provider args not found or not a map[string]interface{}")
	}

	// A more robust way would be to use a library like mitchellh/mapstructure to decode into PgVectorStoreConfig
	connStr, _ := providerArgs["connection_string"].(string)
	tableName, _ := providerArgs["table_name"].(string)
	embeddingDimFloat, _ := providerArgs["embedding_dimension"].(float64) // JSON numbers are float64
	embeddingDim := int(embeddingDimFloat)
	collectionName, _ := providerArgs["collection_name"].(string)

	if connStr == "" || tableName == "" || embeddingDim == 0 {
		return nil, fmt.Errorf("pgvector: connection_string, table_name, and embedding_dimension are required")
	}

	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to open postgres connection: %w", err)
	}
	if err = db.PingContext(ctx); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to ping postgres: %w", err)
	}

	store := &PgVectorStore{
		db:             db,
		tableName:      tableName,
		embeddingDim:   embeddingDim,
		collectionName: collectionName,
		name:           "pgvector",
	}

	// Initialize table (this is a simplified example, production code needs more robust schema management)
	err = store.ensureTableExists(ctx)
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to ensure pgvector table exists: %w", err)
	}

	return store, nil
}

func (s *PgVectorStore) ensureTableExists(ctx context.Context) error {
	// Example DDL. Production code should handle migrations and more complex schema.
	// The vector type depends on the pgvector extension.
	// Example: CREATE EXTENSION IF NOT EXISTS vector;
	// CREATE TABLE IF NOT EXISTS items (id bigserial PRIMARY KEY, embedding vector(3), content text);
	query := fmt.Sprintf(`
	CREATE EXTENSION IF NOT EXISTS vector;
	CREATE TABLE IF NOT EXISTS %s (
		id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
		content TEXT,
		metadata JSONB,
		embedding VECTOR(%d),
		collection_name TEXT
	);
	CREATE INDEX IF NOT EXISTS %s_embedding_idx ON %s USING HNSW (embedding vector_l2_ops);
	`, s.tableName, s.embeddingDim, s.tableName, s.tableName) // Example index

	_, err := s.db.ExecContext(ctx, query)
	return err
}

// AddDocuments adds documents to the PgVectorStore.
func (s *PgVectorStore) AddDocuments(ctx context.Context, docs []schema.Document, embedder iface.Embedder) error {
	if embedder == nil {
		return fmt.Errorf("pgvector: embedder is required to add documents")
	}

	// Begin transaction
	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback() // Rollback if not committed

	stmt, err := tx.PrepareContext(ctx, fmt.Sprintf("INSERT INTO %s (id, content, metadata, embedding, collection_name) VALUES ($1, $2, $3, $4, $5)", s.tableName))
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, doc := range docs {
		var docEmbedding []float32
		if doc.Embedding != nil && len(doc.Embedding) > 0 {
			docEmbedding = doc.Embedding
		} else {
			embeds, err := embedder.EmbedDocuments(ctx, []string{doc.PageContent})
			if err != nil {
				return fmt.Errorf("failed to embed document 	%s	: %w", doc.ID, err)
			}
			if len(embeds) == 0 {
				return fmt.Errorf("embedder returned no embeddings for document 	%s", doc.ID)
			}
			docEmbedding = embeds[0]
		}

		if len(docEmbedding) != s.embeddingDim {
			return fmt.Errorf("document 	%s	 embedding dimension %d does not match store dimension %d", doc.ID, len(docEmbedding), s.embeddingDim)
		}

		// pgvector typically expects embeddings as a string like "[1,2,3]"
		embeddingStr := fmt.Sprintf("[%s]", float32SliceToString(docEmbedding, ","))

		// Convert metadata map to JSONB string (simplified, use json.Marshal for robustness)
		metadataStr := "{}"
		if doc.Metadata != nil {
			// metadataBytes, _ := json.Marshal(doc.Metadata) // Proper way
			// metadataStr = string(metadataBytes)
			// For simplicity now, assuming it's a simple map that can be stringified easily or is already JSON
			metadataStr = fmt.Sprintf("%v", doc.Metadata) // Placeholder
		}

		_, err = stmt.ExecContext(ctx, doc.ID, doc.PageContent, metadataStr, embeddingStr, s.collectionName)
		if err != nil {
			return fmt.Errorf("failed to insert document 	%s	: %w", doc.ID, err)
		}
	}

	return tx.Commit()
}

// SimilaritySearch performs a similarity search using a pre-computed query vector.
func (s *PgVectorStore) SimilaritySearch(ctx context.Context, queryVector []float32, k int) ([]schema.Document, []float32, error) {
	if len(queryVector) != s.embeddingDim {
		return nil, nil, fmt.Errorf("query vector dimension %d does not match store dimension %d", len(queryVector), s.embeddingDim)
	}

	queryEmbeddingStr := fmt.Sprintf("[%s]", float32SliceToString(queryVector, ","))

	// Example query using L2 distance (<-> operator for pgvector)
	// Other operators: <#> for negative inner product, <=> for cosine distance
	query := fmt.Sprintf(
		"SELECT id, content, metadata, embedding <-> $1 AS distance FROM %s WHERE collection_name = $2 ORDER BY distance LIMIT $3",
		s.tableName,
	)
	if s.collectionName == "" {
		query = fmt.Sprintf(
			"SELECT id, content, metadata, embedding <-> $1 AS distance FROM %s ORDER BY distance LIMIT $2",
			s.tableName,
		)
	}

	var rows *sql.Rows
	var err error

	if s.collectionName == "" {
		rows, err = s.db.QueryContext(ctx, query, queryEmbeddingStr, k)
	} else {
		rows, err = s.db.QueryContext(ctx, query, queryEmbeddingStr, s.collectionName, k)
	}

	if err != nil {
		return nil, nil, fmt.Errorf("failed to execute similarity search query: %w", err)
	}
	defer rows.Close()

	var resultDocs []schema.Document
	var resultScores []float32

	for rows.Next() {
		var doc schema.Document
		var distance float32
		// var embeddingStr string // pgvector returns embedding as string - This variable is not used in the current logic.
		var metadataStr sql.NullString // Assuming metadata is stored as JSONB and retrieved as string

		if err := rows.Scan(&doc.ID, &doc.PageContent, &metadataStr, &distance); err != nil {
			return nil, nil, fmt.Errorf("failed to scan row: %w", err)
		}
		// Convert distance to similarity score (e.g., 1 - distance for cosine distance, or handle L2 appropriately)
		// For L2 distance, smaller is better. If a score where higher is better is needed, transform it.
		// For simplicity, we return L2 distance as the "score" here, noting smaller is better.
		resultScores = append(resultScores, distance)

		// Parse metadataStr (JSON) into doc.Metadata map[string]string
			if metadataStr.Valid && metadataStr.String != "" && metadataStr.String != "{}" {
				var parsedMeta map[string]string
				if err := json.Unmarshal([]byte(metadataStr.String), &parsedMeta); err == nil {
					doc.Metadata = parsedMeta
				} else {
					// Handle error or set a default, e.g., log the error
					// For now, we can assign the raw string to a special key if parsing fails
					doc.Metadata = map[string]string{"_raw_pgvector_metadata_error": metadataStr.String, "_parsing_error": err.Error()}
				}
			} else {
				doc.Metadata = make(map[string]string) // Ensure it's not nil
			}
		resultDocs = append(resultDocs, doc)
	}

	return resultDocs, resultScores, rows.Err()
}

// SimilaritySearchByQuery generates an embedding for the query and then performs a similarity search.
func (s *PgVectorStore) SimilaritySearchByQuery(ctx context.Context, query string, k int, embedder iface.Embedder) ([]schema.Document, []float32, error) {
	if embedder == nil {
		return nil, nil, fmt.Errorf("pgvector: embedder is required for SimilaritySearchByQuery")
	}

	queryEmbedding, err := embedder.EmbedQuery(ctx, query)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to embed query: %w", err)
	}

	return s.SimilaritySearch(ctx, queryEmbedding, k)
}

// GetName returns the name of the vector store.
func (s *PgVectorStore) GetName() string {
	return s.name
}

// float32SliceToString converts a slice of float32 to a comma-separated string.
func float32SliceToString(slice []float32, separator string) string {
	strVals := make([]string, len(slice))
	for i, v := range slice {
		strVals[i] = fmt.Sprintf("%f", v)
	}
	return string(JoinBytes([]byte(separator), strVals...))
}

// JoinBytes is a helper to join string parts with a byte separator.
// This is a simplified helper; strings.Join is usually sufficient.
func JoinBytes(sep []byte, parts ...string) []byte {
	if len(parts) == 0 {
		return []byte{}
	}
	n := len(sep) * (len(parts) - 1)
	for i := 0; i < len(parts); i++ {
		n += len(parts[i])
	}

	b := make([]byte, n)
	bp := copy(b, parts[0])
	for _, s := range parts[1:] {
		bp += copy(b[bp:], sep)
		bp += copy(b[bp:], s)
	}
	return b
}

// Ensure PgVectorStore implements the VectorStore interface.
var _ vectorstores.VectorStore = (*PgVectorStore)(nil)

// PgVectorStoreFactory creates PgVectorStore instances.
type PgVectorStoreFactory struct{}

// NewPgVectorStoreFactory creates a new PgVectorStoreFactory.
func NewPgVectorStoreFactory() *PgVectorStoreFactory {
	return &PgVectorStoreFactory{}
}

// CreateVectorStore creates a new PgVectorStore using the provided configuration.
func (f *PgVectorStoreFactory) CreateVectorStore(ctx context.Context, config vectorstores.Config) (vectorstores.VectorStore, error) {
	if config.Type != "pgvector" {
		return nil, fmt.Errorf("pgvector factory cannot create vector store of type 	%s", config.Type)
	}
	return NewPgVectorStore(ctx, config)
}

// Ensure PgVectorStoreFactory implements the Factory interface.
var _ vectorstores.Factory = (*PgVectorStoreFactory)(nil)

File: ./config/models.go
package config

// GlobalConfig is a placeholder for a global application configuration structure.
// Specific components can define their own configuration structs that can be loaded
// by a config.Provider.
// For example, an LLM provider might have its own LLMConfig struct.
type GlobalConfig struct {
	AppName    string `mapstructure:"app_name"`
	LogLevel   string `mapstructure:"log_level"`
	ServerPort int    `mapstructure:"server_port"`
	// Other global settings can be added here.
}

// ComponentConfig is an example of how a specific component might define its configuration.
// This would typically be defined within the component's own package, but is shown here for illustration.
type ComponentConfig struct {
	Enabled bool   `mapstructure:"enabled"`
	APIKey  string `mapstructure:"api_key"`
	Timeout int    `mapstructure:"timeout_seconds"`
}



// OpenAIEmbedderConfig holds configuration for the OpenAI Embedder.
type OpenAIEmbedderConfig struct {
	APIKey      string `mapstructure:"api_key"`
	Model       string `mapstructure:"model"`         // e.g., "text-embedding-ada-002"
	APIVersion  string `mapstructure:"api_version"`   // Optional: For Azure OpenAI
	APIEndpoint string `mapstructure:"api_endpoint"` // Optional: For Azure OpenAI or other proxies
	Timeout     int    `mapstructure:"timeout_seconds"`
}



// MockEmbedderConfig holds configuration for the Mock Embedder.
type MockEmbedderConfig struct {
	Dimension    int   `mapstructure:"dimension"`
	Seed         int64 `mapstructure:"seed"`
	RandomizeNil bool  `mapstructure:"randomize_nil"`
}




// ToolConfig defines the configuration for a specific tool instance.
type ToolConfig struct {
	Name        string                 `mapstructure:"name" yaml:"name"`                 // Unique name for this tool instance
	Description string                 `mapstructure:"description" yaml:"description"`     // Description of what the tool does
	Provider    string                 `mapstructure:"provider" yaml:"provider"`           // The provider for this tool (e.g., "echo", "calculator")
	Enabled     bool                   `mapstructure:"enabled" yaml:"enabled"`             // Whether the tool is enabled
	Config      map[string]interface{} `mapstructure:"config" yaml:"config,omitempty"` // Provider-specific configuration for the tool
}



// OpenAILLMConfig holds configuration for the OpenAI LLM provider.
type OpenAILLMConfig struct {
	Model            string   `mapstructure:"model_name" yaml:"model_name"`
	APIKey           string   `mapstructure:"api_key" yaml:"api_key"`
	Temperature      float64  `mapstructure:"temperature" yaml:"temperature,omitempty"`
	MaxTokens        int      `mapstructure:"max_tokens" yaml:"max_tokens,omitempty"`
	TopP             float64  `mapstructure:"top_p" yaml:"top_p,omitempty"`
	FrequencyPenalty float64  `mapstructure:"frequency_penalty" yaml:"frequency_penalty,omitempty"`
	PresencePenalty  float64  `mapstructure:"presence_penalty" yaml:"presence_penalty,omitempty"`
	Stop             []string `mapstructure:"stop" yaml:"stop,omitempty"`
	Streaming        bool     `mapstructure:"streaming" yaml:"streaming,omitempty"`
	APIVersion       string   `mapstructure:"api_version" yaml:"api_version,omitempty"`   // Optional: For Azure OpenAI
	APIEndpoint      string   `mapstructure:"api_endpoint" yaml:"api_endpoint,omitempty"` // Optional: For Azure OpenAI or other proxies
	Timeout          int      `mapstructure:"timeout_seconds" yaml:"timeout_seconds,omitempty"`
}

// MockLLMConfig holds configuration for the Mock LLM provider.
type MockLLMConfig struct {
	ModelName     string                 `mapstructure:"model_name" yaml:"model_name"`
	ExpectedError string                 `mapstructure:"expected_error" yaml:"expected_error,omitempty"`
	Responses     []string               `mapstructure:"responses" yaml:"responses,omitempty"`
	ToolCalls     []map[string]interface{} `mapstructure:"tool_calls" yaml:"tool_calls,omitempty"` // Simplified for now
}
File: ./monitoring/logger.go
package monitoring

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"sync"
)

// LogLevel represents the severity of a log entry.
type LogLevel int

const (
	// Log levels
	DEBUG LogLevel = iota
	INFO
	WARNING
	ERROR
	FATAL
)

// String returns the string representation of the log level.
func (l LogLevel) String() string {
	switch l {
	case DEBUG:
		return "DEBUG"
	case INFO:
		return "INFO"
	case WARNING:
		return "WARN"
	case ERROR:
		return "ERROR"
	case FATAL:
		return "FATAL"
	default:
		return "UNKNOWN"
	}
}

// Logger provides a standardized logging mechanism.
type Logger struct {
	name      string
	mutex     sync.Mutex
	level     LogLevel
	stdout    *log.Logger
	fileOut   *log.Logger
	file      *os.File
	useColors bool
}

// LoggerConfig contains configuration options for creating a logger.
type LoggerConfig struct {
	Level       LogLevel
	EnableColor bool
	OutputFile  string
	UseConsole  bool
}

// DefaultLoggerConfig returns a default configuration for the logger.
func DefaultLoggerConfig() LoggerConfig {
	return LoggerConfig{
		Level:       INFO,
		EnableColor: true,
		UseConsole:  true,
	}
}

// NewLogger creates a new instance of Logger with the given name.
func NewLogger(name string) *Logger {
	config := DefaultLoggerConfig()
	return NewLoggerWithConfig(name, config)
}

// NewLoggerWithConfig creates a new instance of Logger with the given name and configuration.
func NewLoggerWithConfig(name string, config LoggerConfig) *Logger {
	logger := &Logger{
		name:      name,
		level:     config.Level,
		stdout:    log.New(os.Stdout, "", 0),
		useColors: config.EnableColor,
	}

	if config.OutputFile != "" {
		if err := os.MkdirAll(filepath.Dir(config.OutputFile), 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error creating log directory: %v\n", err)
		} else {
			file, err := os.OpenFile(config.OutputFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error opening log file: %v\n", err)
			} else {
				logger.file = file
				logger.fileOut = log.New(file, "", log.LstdFlags)
			}
		}
	}

	if !config.UseConsole {
		logger.stdout = nil
	}

	return logger
}

// formatLogMessage formats a log entry with timestamp, level, and caller information.
func (l *Logger) formatLogMessage(level LogLevel, message string, args ...interface{}) string {
	var caller string
	if _, file, line, ok := runtime.Caller(2); ok {
		caller = fmt.Sprintf("%s:%d", filepath.Base(file), line)
	} else {
		caller = "unknown:0"
	}

	prefix := fmt.Sprintf("[%s][%s][%s] ", l.name, level.String(), caller)

	// Format the message if there are arguments
	if len(args) > 0 {
		message = fmt.Sprintf(message, args...)
	}

	return prefix + message
}

// colorize adds ANSI color to a string based on log level.
func (l *Logger) colorize(level LogLevel, text string) string {
	if !l.useColors {
		return text
	}

	var color string
	switch level {
	case DEBUG:
		color = "\033[37m" // White
	case INFO:
		color = "\033[32m" // Green
	case WARNING:
		color = "\033[33m" // Yellow
	case ERROR:
		color = "\033[31m" // Red
	case FATAL:
		color = "\033[35m" // Magenta
	default:
		return text
	}

	reset := "\033[0m"
	return color + text + reset
}

// log outputs a log entry to stdout and file if enabled.
func (l *Logger) log(level LogLevel, message string, args ...interface{}) {
	if level < l.level {
		return
	}

	l.mutex.Lock()
	defer l.mutex.Unlock()

	formattedMsg := l.formatLogMessage(level, message, args...)

	if l.stdout != nil {
		colorizedMsg := l.colorize(level, formattedMsg)
		l.stdout.Println(colorizedMsg)
	}

	if l.fileOut != nil {
		l.fileOut.Println(formattedMsg)
	}

	if level == FATAL {
		os.Exit(1)
	}
}

// Debug logs debug information.
func (l *Logger) Debug(message string, args ...interface{}) {
	l.log(DEBUG, message, args...)
}

// Info logs informational messages.
func (l *Logger) Info(message string, args ...interface{}) {
	l.log(INFO, message, args...)
}

// Warning logs warning messages.
func (l *Logger) Warning(message string, args ...interface{}) {
	l.log(WARNING, message, args...)
}

// Error logs error messages.
func (l *Logger) Error(message string, args ...interface{}) {
	l.log(ERROR, message, args...)
}

// Fatal logs fatal messages and exits the application with status code 1.
func (l *Logger) Fatal(message string, args ...interface{}) {
	l.log(FATAL, message, args...)
}

// SetLevel changes the current log level.
func (l *Logger) SetLevel(level LogLevel) {
	l.mutex.Lock()
	defer l.mutex.Unlock()
	l.level = level
}

// Close closes the logger's file if one is open.
func (l *Logger) Close() error {
	l.mutex.Lock()
	defer l.mutex.Unlock()

	if l.file != nil {
		return l.file.Close()
	}
	return nil
}

// GetWriter returns an io.Writer interface for the logger at the specified level.
func (l *Logger) GetWriter(level LogLevel) io.Writer {
	return &logWriter{
		logger: l,
		level:  level,
	}
}

// logWriter is an io.Writer implementation that writes to the logger.
type logWriter struct {
	logger *Logger
	level  LogLevel
}

// Write implements the io.Writer interface.
func (w *logWriter) Write(p []byte) (n int, err error) {
	w.logger.log(w.level, string(p))
	return len(p), nil
}