package internal

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"text/template"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/lookatitude/beluga-ai/pkg/prompts/iface"
	"github.com/lookatitude/beluga-ai/pkg/schema"
)

// Note: Options struct is defined in the main prompts package

// StringPromptValue holds a simple string output from a template.
// This is typically used for completion-style LLMs.
type StringPromptValue struct {
	Value string
}

// ToString implements the iface.PromptValue interface.
func (spv StringPromptValue) ToString() string {
	return spv.Value
}

// ToMessages implements the iface.PromptValue interface.
// It typically converts the string into a single schema.HumanMessage.
// This behavior might need adjustment based on specific use cases in chains or agents.
func (spv StringPromptValue) ToMessages() []schema.Message {
	return []schema.Message{schema.NewHumanMessage(spv.Value)}
}

// ChatPromptValue holds a sequence of messages generated by a chat prompt template.
// This is used for chat-based LLMs.
type ChatPromptValue struct {
	Messages []schema.Message
}

// ToString implements the iface.PromptValue interface.
// It provides a basic string representation of the chat messages, primarily for logging or debugging.
func (cpv ChatPromptValue) ToString() string {
	var builder strings.Builder
	for _, msg := range cpv.Messages {
		builder.WriteString(fmt.Sprintf("%s: %s\n", msg.GetType(), msg.GetContent()))
	}
	return builder.String()
}

// ToMessages implements the iface.PromptValue interface.
func (cpv ChatPromptValue) ToMessages() []schema.Message {
	return cpv.Messages
}

// BaseTemplate provides common functionality for prompt templates,
// such as storing the list of expected input variables.
// Specific template types (like StringPromptTemplate, ChatPromptTemplate) can embed this.
type BaseTemplate struct {
	name      string
	variables []string
	metrics   iface.Metrics
	tracer    iface.Tracer
	logger    iface.Logger
	config    *iface.Config
}

// Name returns the template name
func (b *BaseTemplate) Name() string {
	return b.name
}

// InputVariables returns the list of expected variable names.
func (b *BaseTemplate) InputVariables() []string {
	return b.variables
}

// Validate validates the template structure
func (b *BaseTemplate) Validate() error {
	if b.name == "" {
		return iface.NewValidationError("validate", "template name cannot be empty", nil)
	}
	if len(b.variables) == 0 {
		return iface.NewValidationError("validate", "template must have at least one variable", nil)
	}
	return nil
}

// StringPromptTemplate formats a template string using Go's text/template package.
// It produces a StringPromptValue.
type StringPromptTemplate struct {
	BaseTemplate
	template *template.Template // The parsed Go template
}

// NewStringPromptTemplate creates a new StringPromptTemplate from a template string.
// It parses the template string to identify variables and parses the template using Go's text/template.
func NewStringPromptTemplate(name, templateString string, opts ...iface.Option) (*StringPromptTemplate, error) {
	// Apply options
	options := &iface.Options{}
	for _, opt := range opts {
		opt(options)
	}

	// Extract variables
	vars, err := extractVariables(templateString)
	if err != nil {
		return nil, iface.NewTemplateParseError("new_string_template", name, err)
	}

	// Use Go's template engine
	tmpl, err := template.New(name).Parse(templateString)
	if err != nil {
		return nil, iface.NewTemplateParseError("new_string_template", name, err)
	}

	spt := &StringPromptTemplate{
		BaseTemplate: BaseTemplate{
			name:      name,
			variables: vars,
			metrics:   options.Metrics,
			tracer:    options.Tracer,
			logger:    options.Logger,
			config:    options.Config,
		},
		template: tmpl,
	}

	// Record metrics
	if spt.metrics != nil {
		spt.metrics.RecordTemplateCreated("string")
	}

	return spt, nil
}

// Format implements the iface.Template interface.
func (spt *StringPromptTemplate) Format(ctx context.Context, variables map[string]interface{}) (interface{}, error) {
	ctx, span := spt.tracer.Start(ctx, "string_template.format",
		trace.WithAttributes(
			attribute.String("template.name", spt.name),
			attribute.Int("variables.count", len(variables)),
		))
	defer span.End()

	start := time.Now()

	// Validate variables if enabled
	if spt.config != nil && spt.config.ValidateVariables {
		if err := spt.validateVariables(variables); err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			if spt.metrics != nil {
				spt.metrics.RecordValidationError("variable_validation")
			}
			return nil, err
		}
	}

	var buf strings.Builder

	err := spt.template.Execute(&buf, variables)
	duration := time.Since(start).Seconds()

	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
		if spt.metrics != nil {
			spt.metrics.RecordTemplateError(spt.name, "execution")
		}
		return nil, iface.NewTemplateExecuteError("format", spt.name, err)
	}

	span.SetAttributes(attribute.Float64("duration_seconds", duration))

	if spt.metrics != nil {
		spt.metrics.RecordTemplateExecuted(spt.name, duration)
	}

	return StringPromptValue{Value: buf.String()}, nil
}

// GetInputVariables returns the list of expected input variables.
func (spt *StringPromptTemplate) GetInputVariables() []string {
	return spt.variables
}

// validateVariables validates that all required variables are present and have correct types
func (spt *StringPromptTemplate) validateVariables(variables map[string]interface{}) error {
	provided := make(map[string]bool)
	for k := range variables {
		provided[k] = true
	}

	for _, required := range spt.variables {
		if !provided[required] {
			return iface.NewVariableMissingError("validate_variables", required, spt.name)
		}
		// Basic type validation - can be extended
		if variables[required] == nil {
			return iface.NewVariableInvalidError("validate_variables", required, "non-nil", "nil")
		}
	}

	return nil
}

// Helper function to extract variables (basic example, needs robust implementation)
// A real implementation should parse the template syntax correctly.
func extractVariables(templateString string) ([]string, error) {
	vars := make(map[string]struct{})
	// Example crude regex:
	re := regexp.MustCompile(`{{\.([\w]+)}}`)
	matches := re.FindAllStringSubmatch(templateString, -1)
	for _, match := range matches {
		if len(match) > 1 {
			vars[match[1]] = struct{}{}
		}
	}

	// Allow templates without variables

	varList := make([]string, 0, len(vars))
	for v := range vars {
		varList = append(varList, v)
	}
	return varList, nil
}

// Compile-time checks to ensure implementations satisfy interfaces.
var _ iface.Template = (*StringPromptTemplate)(nil)
var _ iface.PromptValue = (*StringPromptValue)(nil)
var _ iface.PromptValue = (*ChatPromptValue)(nil)
