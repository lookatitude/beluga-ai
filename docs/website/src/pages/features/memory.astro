---
import FeaturePageLayout from "@/components/marketing/FeaturePageLayout.astro";

const jsonLd = JSON.stringify({
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "name": "Memory Systems — Beluga AI",
  "description": "Three-tier MemGPT memory model with 6 strategies and 7 store backends. Self-editable core memory for persistent agent personality.",
  "url": "https://beluga-ai.org/features/memory/"
});
---

<FeaturePageLayout
  pageTitle="Memory Systems | Beluga AI"
  description="Three-tier MemGPT memory model with 6 strategies and 7 store backends. Self-editable core memory for persistent agent personality."
  title="Memory Systems"
  jsonLd={jsonLd}
  subtitle="Three-tier MemGPT memory (Core, Recall, Archival) with 6 strategies: buffer, window, summary, entity, semantic, and graph. Self-editable via agent tools for persistent personality and knowledge."
  layer="Capability"
  stats={["3-Tier MemGPT", "6 Strategies", "Graph Memory", "Self-Editable"]}
  showProvidersTable={true}
  relatedFeatures={[
    { title: "Agent Runtime", href: "/features/agents/", description: "Build autonomous agents with planning, tool use, and handoffs between specialized agents." },
    { title: "RAG Pipeline", href: "/features/rag/", description: "Retrieval-Augmented Generation with hybrid search, CRAG, and HyDE strategies." },
    { title: "Observability", href: "/features/observability/", description: "OpenTelemetry-native tracing with GenAI semantic conventions and structured logging." },
  ]}
>
  <Fragment slot="overview">
    <p>
      Memory is what transforms a stateless LLM into a persistent, context-aware agent. Beluga AI implements
      the <strong>MemGPT three-tier memory model</strong>, giving agents a structured approach to managing
      information across conversations and sessions. Rather than dumping everything into a context window,
      agents decide what to remember, what to search for, and what to archive — just as humans manage
      working memory, episodic recall, and long-term knowledge differently.
    </p>
    <p>
      The three tiers are: <strong>Core Memory</strong> (always present in the LLM context — personality,
      user preferences, active goals), <strong>Recall Memory</strong> (searchable conversation history with
      multiple retrieval strategies), and <strong>Archival Memory</strong> (long-term vector and graph storage
      for knowledge that persists indefinitely). Agents can combine these tiers through a composite memory
      system that unifies working, episodic, semantic, and graph memory behind a single interface.
    </p>
    <p>
      A key differentiator is <strong>self-editable core memory</strong>: agents are given tools to read and
      write their own core memory blocks. This means an agent can update its understanding of a user's
      preferences, record important decisions, or adjust its own personality traits — all without external
      intervention. Seven store backends (from in-memory for development to Neo4j for graph relationships)
      ensure the right storage for every deployment scenario.
    </p>
  </Fragment>

  <Fragment slot="capabilities">
    <h3>Three-Tier Memory (MemGPT)</h3>
    <p>
      <strong>Core Memory</strong> lives permanently in the agent's system prompt — it holds personality
      traits, user preferences, and active goals. <strong>Recall Memory</strong> is searchable conversation
      history, indexed by time, topic, and relevance, allowing agents to retrieve past interactions on
      demand. <strong>Archival Memory</strong> provides long-term storage via vector embeddings and graph
      relationships, persisting knowledge across sessions indefinitely. Each tier has distinct read/write
      characteristics optimized for its access pattern.
    </p>

    <h3>Memory Strategies</h3>
    <p>
      Six strategies control how conversation context flows into memory:
    </p>
    <ul>
      <li><strong>Buffer</strong> — Keeps all messages in context up to a token limit, then truncates oldest.</li>
      <li><strong>Window</strong> — Sliding window of the last N messages, simple and predictable.</li>
      <li><strong>Summary</strong> — Periodically summarizes older messages, compressing history while preserving key points.</li>
      <li><strong>Entity</strong> — Extracts and tracks entities (people, places, concepts) mentioned across conversations.</li>
      <li><strong>Semantic</strong> — Embeds messages and retrieves by semantic similarity to the current query.</li>
      <li><strong>Graph</strong> — Builds a knowledge graph from conversations, capturing relationships between entities.</li>
    </ul>

    <h3>Composite Memory</h3>
    <p>
      The composite memory system combines multiple memory types behind a unified interface. A typical
      production setup might use <strong>Working Memory</strong> (buffer strategy for immediate context),
      <strong>Episodic Memory</strong> (window + summary for conversation history), <strong>Semantic
      Memory</strong> (vector-based for knowledge retrieval), and <strong>Graph Memory</strong> (Neo4j or
      Memgraph for relationship queries). The composite layer handles routing queries to the appropriate
      memory tier and merging results.
    </p>

    <h3>Self-Editable Core Memory</h3>
    <p>
      Agents are given specialized tools — <code>core_memory_read</code>, <code>core_memory_write</code>,
      and <code>core_memory_replace</code> — that let them modify their own core memory blocks. When an
      agent learns a user's name, discovers a preference, or needs to update a goal, it can persist that
      information directly. This creates agents that genuinely learn and adapt over time, maintaining
      personality consistency across thousands of interactions.
    </p>

    <h3>Store Backends</h3>
    <p>
      Seven store backends cover the full range of deployment scenarios:
    </p>
    <ul>
      <li><strong>In-Memory</strong> — Zero-config for development and testing.</li>
      <li><strong>Redis</strong> — Fast key-value access for session-scoped memory.</li>
      <li><strong>PostgreSQL</strong> — Durable relational storage with pgvector for embeddings.</li>
      <li><strong>SQLite</strong> — Embedded storage for single-node or edge deployments.</li>
      <li><strong>Neo4j</strong> — Native graph database for relationship-heavy memory.</li>
      <li><strong>DragonflyDB</strong> — Redis-compatible with better memory efficiency at scale.</li>
      <li><strong>Memgraph</strong> — In-memory graph database for low-latency graph queries.</li>
    </ul>
  </Fragment>

  <Fragment slot="diagram">
    <div style="display:flex;flex-direction:column;gap:2rem;align-items:center;padding:1.5rem 0;">
      <!-- Three-Tier Model -->
      <div style="text-align:center;margin-bottom:0.5rem;">
        <strong style="font-size:0.875rem;opacity:0.7;">MemGPT Three-Tier Memory Model</strong>
      </div>

      <div style="display:flex;flex-direction:column;gap:0.75rem;width:100%;max-width:600px;">
        <!-- Core Memory -->
        <div style="display:flex;align-items:center;gap:1rem;padding:0.875rem 1.25rem;border-radius:0.5rem;background:color-mix(in srgb, #D76D77 12%, transparent);border:1px solid color-mix(in srgb, #D76D77 30%, transparent);">
          <div style="font-size:0.8125rem;font-weight:600;min-width:6rem;">Core</div>
          <div style="font-size:0.75rem;opacity:0.8;">Always in context — personality, preferences, goals. Self-editable by agent.</div>
        </div>

        <!-- Recall Memory -->
        <div style="display:flex;align-items:center;gap:1rem;padding:0.875rem 1.25rem;border-radius:0.5rem;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 25%, transparent);">
          <div style="font-size:0.8125rem;font-weight:600;min-width:6rem;">Recall</div>
          <div style="font-size:0.75rem;opacity:0.8;">Searchable history — past conversations indexed by time, topic, relevance.</div>
        </div>

        <!-- Archival Memory -->
        <div style="display:flex;align-items:center;gap:1rem;padding:0.875rem 1.25rem;border-radius:0.5rem;background:color-mix(in srgb, #ffca7b 10%, transparent);border:1px solid color-mix(in srgb, #ffca7b 25%, transparent);">
          <div style="font-size:0.8125rem;font-weight:600;min-width:6rem;">Archival</div>
          <div style="font-size:0.75rem;opacity:0.8;">Long-term storage — vector embeddings + graph relationships. Persistent across sessions.</div>
        </div>
      </div>

      <!-- Strategies -->
      <div style="text-align:center;margin-top:1rem;margin-bottom:0.5rem;">
        <strong style="font-size:0.875rem;opacity:0.7;">Memory Strategies</strong>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:0.5rem;justify-content:center;">
        <div style="padding:0.4rem 0.75rem;border-radius:9999px;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Buffer</div>
        <div style="padding:0.4rem 0.75rem;border-radius:9999px;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Window</div>
        <div style="padding:0.4rem 0.75rem;border-radius:9999px;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Summary</div>
        <div style="padding:0.4rem 0.75rem;border-radius:9999px;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Entity</div>
        <div style="padding:0.4rem 0.75rem;border-radius:9999px;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Semantic</div>
        <div style="padding:0.4rem 0.75rem;border-radius:9999px;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Graph</div>
      </div>

      <!-- Data Flow -->
      <div style="text-align:center;margin-top:1rem;margin-bottom:0.5rem;">
        <strong style="font-size:0.875rem;opacity:0.7;">Composite Memory Flow</strong>
      </div>
      <div style="display:flex;align-items:center;gap:0.75rem;flex-wrap:wrap;justify-content:center;">
        <div style="padding:0.6rem 1rem;border-radius:0.5rem;background:color-mix(in srgb, var(--color-primary) 15%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 30%, transparent);font-size:0.8125rem;font-weight:500;">
          Agent Query
        </div>
        <span style="color:var(--color-primary);font-weight:bold;">&#8594;</span>
        <div style="padding:0.6rem 1rem;border-radius:0.5rem;background:color-mix(in srgb, #D76D77 15%, transparent);border:1px solid color-mix(in srgb, #D76D77 35%, transparent);font-size:0.8125rem;font-weight:600;">
          Composite Router
        </div>
        <span style="color:var(--color-primary);font-weight:bold;">&#8594;</span>
        <div style="display:flex;flex-direction:column;gap:0.375rem;">
          <div style="padding:0.35rem 0.75rem;border-radius:0.375rem;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Working</div>
          <div style="padding:0.35rem 0.75rem;border-radius:0.375rem;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Episodic</div>
          <div style="padding:0.35rem 0.75rem;border-radius:0.375rem;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Semantic</div>
          <div style="padding:0.35rem 0.75rem;border-radius:0.375rem;background:color-mix(in srgb, var(--color-primary) 12%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);font-size:0.75rem;">Graph</div>
        </div>
        <span style="color:var(--color-primary);font-weight:bold;">&#8594;</span>
        <div style="padding:0.6rem 1rem;border-radius:0.5rem;background:color-mix(in srgb, var(--color-primary) 15%, transparent);border:1px solid color-mix(in srgb, var(--color-primary) 30%, transparent);font-size:0.8125rem;font-weight:500;">
          Merged Context
        </div>
      </div>
    </div>
  </Fragment>

  <Fragment slot="providers">
    <h3>Memory Store Backends</h3>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Priority</th>
          <th>Key Differentiator</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>In-Memory</td><td>P0</td><td>Zero-config, ideal for development and testing</td></tr>
        <tr><td>Redis</td><td>P0</td><td>Fast key-value access, TTL support, session-scoped memory</td></tr>
        <tr><td>PostgreSQL</td><td>P0</td><td>Durable relational storage with pgvector for embeddings</td></tr>
        <tr><td>SQLite</td><td>P1</td><td>Embedded single-file storage, edge and mobile deployments</td></tr>
        <tr><td>Neo4j</td><td>P1</td><td>Native graph database for relationship-heavy memory patterns</td></tr>
        <tr><td>DragonflyDB</td><td>P2</td><td>Redis-compatible with 25x memory efficiency at scale</td></tr>
        <tr><td>Memgraph</td><td>P2</td><td>In-memory graph for sub-millisecond relationship queries</td></tr>
      </tbody>
    </table>
  </Fragment>

  <Fragment slot="codeExample">
    <p>An agent configured with composite memory combining all four memory types:</p>
    <pre><code>package main

import (
    "context"
    "fmt"
    "log"

    "github.com/lookatitude/beluga-ai/agent"
    "github.com/lookatitude/beluga-ai/llm"
    "github.com/lookatitude/beluga-ai/memory"
    "github.com/lookatitude/beluga-ai/memory/stores/inmemory"
    "github.com/lookatitude/beluga-ai/memory/stores/postgres"
    _ "github.com/lookatitude/beluga-ai/llm/providers/openai"
)

func main() &#123;
    ctx := context.Background()

    model, err := llm.New("openai", llm.ProviderConfig&#123;
        Model: "gpt-4o",
    &#125;)
    if err != nil &#123;
        log.Fatal(err)
    &#125;

    // Configure store backends
    devStore := inmemory.New()
    pgStore, err := postgres.New(
        postgres.WithDSN("postgres://localhost:5432/beluga"),
        postgres.WithEmbeddingDimension(1536),
    )
    if err != nil &#123;
        log.Fatal(err)
    &#125;

    // Build composite memory with all four tiers
    mem := memory.NewComposite(
        // Working memory: buffer strategy, always in context
        memory.WithWorking(memory.NewCore(
            memory.WithStore(devStore),
            memory.WithBlocks("personality", "user_preferences", "active_goals"),
            memory.WithSelfEditable(true), // Agent can modify via tools
        )),

        // Episodic memory: window + summary for conversation history
        memory.WithEpisodic(memory.NewRecall(
            memory.WithStore(pgStore),
            memory.WithStrategy(memory.StrategySummary),
            memory.WithWindowSize(20),
            memory.WithSummaryThreshold(50),
        )),

        // Semantic memory: embedding-based retrieval
        memory.WithSemantic(memory.NewArchival(
            memory.WithStore(pgStore),
            memory.WithStrategy(memory.StrategySemantic),
            memory.WithTopK(5),
        )),

        // Graph memory: entity and relationship tracking
        memory.WithGraph(memory.NewArchival(
            memory.WithStore(pgStore),
            memory.WithStrategy(memory.StrategyGraph),
        )),
    )

    // Create agent with composite memory
    assistant := agent.New("memory-agent",
        agent.WithModel(model),
        agent.WithMemory(mem),
        agent.WithSystemPrompt(`You are a helpful assistant with persistent memory.
You remember user preferences and past conversations.
Use your core_memory_write tool to save important information.`),
    )

    // First conversation — agent learns preferences
    result, err := assistant.Run(ctx, "My name is Alex and I prefer concise answers.")
    if err != nil &#123;
        log.Fatal(err)
    &#125;
    fmt.Println(result)

    // Later conversation — agent recalls preferences from memory
    result, err = assistant.Run(ctx, "What do you remember about me?")
    if err != nil &#123;
        log.Fatal(err)
    &#125;
    fmt.Println(result)
&#125;</code></pre>
  </Fragment>
</FeaturePageLayout>
