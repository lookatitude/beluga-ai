---
description: Enforce standardized design patterns, OTEL, and error handling.
globs: **/*.go
alwaysApply: true
---
# Beluga AI Design Patterns

**MANDATORY**: All code MUST follow these patterns. Reference: `docs/package_design_patterns.md` for complete details.

## Core Principles (MANDATORY)

1. **Interface Segregation Principle (ISP)**: Small, focused interfaces. Avoid "god interfaces".
2. **Dependency Inversion Principle (DIP)**: Depend on abstractions (interfaces), use constructor injection.
3. **Single Responsibility Principle (SRP)**: One responsibility per package/struct/function.
4. **Composition over Inheritance**: Embed interfaces/structs, use functional options.

## Package Structure (REQUIRED)

Every package MUST follow this exact structure:

```
pkg/{package_name}/
├── iface/                    # Interfaces and types (REQUIRED)
├── internal/                 # Private implementation details
├── providers/               # Provider implementations (for multi-provider packages only)
├── config.go                # Configuration structs and validation (REQUIRED)
├── metrics.go               # OTEL metrics implementation (REQUIRED)
├── errors.go                # Custom error types with Op/Err/Code pattern (REQUIRED)
├── {package_name}.go        # Main interfaces and factory functions
├── factory.go OR registry.go # Global factory/registry for multi-provider packages
├── test_utils.go            # Advanced testing utilities and mocks (REQUIRED)
├── advanced_test.go         # Comprehensive test suites (REQUIRED)
└── README.md                # Package documentation (REQUIRED)
```

## Interface Design (MANDATORY)

- **Naming**: "er" suffix for single-method interfaces (e.g., `Embedder`, `Retriever`); noun-based names for multi-method (e.g., `VectorStore`, `Agent`).
- **Stability**: Maintain backward compatibility; use embedding to extend interfaces.
- **Factory Pattern**: Use `NewXXX` with functional options for all constructors.

Example:
```go
type LLMCaller interface {
    Generate(ctx context.Context, prompt string) (string, error)
}

func NewLLM(caller LLMCaller, opts ...Option) (*LLM, error) {
    // implementation with options
}
```

## Global Registry Pattern (REQUIRED for Multi-Provider Packages)

Multi-provider packages MUST implement the global registry pattern:

```go
type ProviderRegistry struct {
    mu       sync.RWMutex
    creators map[string]func(ctx context.Context, config Config) (Interface, error)
}

var globalRegistry = NewProviderRegistry()

func RegisterGlobal(name string, creator func(ctx context.Context, config Config) (Interface, error)) {
    globalRegistry.Register(name, creator)
}

func NewProvider(ctx context.Context, name string, config Config) (Interface, error) {
    return globalRegistry.Create(ctx, name, config)
}
```

**✅ Implemented in**: embeddings, memory, agents, vectorstores, llms, and all multi-provider packages.

## Configuration Management (REQUIRED)

- **Location**: Define in `config.go`
- **Struct Tags**: Use `mapstructure`, `yaml`, `env`, `validate` tags
- **Validation**: Use `go-playground/validator/v10` with validation at creation time
- **Options**: Use functional options pattern for runtime configuration

Example:
```go
type Config struct {
    APIKey      string        `mapstructure:"api_key" yaml:"api_key" env:"API_KEY" validate:"required"`
    Model       string        `mapstructure:"model" yaml:"model" env:"MODEL" default:"gpt-3.5-turbo"`
    Timeout     time.Duration `mapstructure:"timeout" yaml:"timeout" env:"TIMEOUT" default:"30s"`
}

type Option func(*Component)

func WithTimeout(timeout time.Duration) Option {
    return func(c *Component) { c.timeout = timeout }
}
```

## Observability - OTEL Only (MANDATORY)

**ALL packages MUST use OpenTelemetry (OTEL) as the ONLY observability solution.**

### Metrics (REQUIRED in metrics.go)

```go
type Metrics struct {
    operationsTotal   metric.Int64Counter
    operationDuration metric.Float64Histogram
    errorsTotal      metric.Int64Counter
    tracer           trace.Tracer
}

func NewMetrics(meter metric.Meter, tracer trace.Tracer) (*Metrics, error) {
    // Create counters and histograms with standardized naming
    // Pattern: {package}_operations_total, {package}_operation_duration_seconds, {package}_errors_total
}

func (m *Metrics) RecordOperation(ctx context.Context, operation string, duration time.Duration, success bool) {
    attrs := []attribute.KeyValue{
        attribute.String("operation", operation),
        attribute.Bool("success", success),
    }
    // Record metrics with attributes
}

func NoOpMetrics() *Metrics {
    return &Metrics{} // For testing
}
```

### Tracing (REQUIRED in all public methods)

```go
func (c *Component) PublicMethod(ctx context.Context, input string) (string, error) {
    ctx, span := c.tracer.Start(ctx, "component.public_method",
        trace.WithAttributes(
            attribute.String("input", input),
        ))
    defer span.End()

    result, err := c.doWork(ctx, input)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return "", err
    }

    span.SetAttributes(attribute.String("result", result))
    return result, nil
}
```

### Structured Logging (REQUIRED)

```go
func logWithOTELContext(ctx context.Context, logger Logger, level string, msg string, fields ...interface{}) {
    span := trace.SpanFromContext(ctx)
    if span.SpanContext().IsValid() {
        traceID := span.SpanContext().TraceID().String()
        spanID := span.SpanContext().SpanID().String()
        // Include trace_id and span_id in logs
    }
    // Log with structured fields
}
```

## Error Handling (MANDATORY)

- **Error Types**: Custom structs with `Op`, `Err`, and `Code` fields
- **Error Codes**: Constants for programmatic handling (e.g., `ErrCodeRateLimit`, `ErrCodeInvalidConfig`)
- **Context**: Always respect context cancellation; use `context.WithTimeout` for deadlines

Example:
```go
type PackageError struct {
    Op   string // operation that failed
    Err  error  // underlying error
    Code string // error code for programmatic handling
}

func (e *PackageError) Error() string {
    return fmt.Sprintf("{package} %s: %v", e.Op, e.Err)
}

func (e *PackageError) Unwrap() error {
    return e.Err
}

const (
    ErrCodeRateLimit     = "rate_limit"
    ErrCodeInvalidConfig = "invalid_config"
    ErrCodeNetworkError  = "network_error"
    ErrCodeTimeout       = "timeout"
)

func NewError(op string, err error, code string) *PackageError {
    return &PackageError{Op: op, Err: err, Code: code}
}
```

## Dependency Management

- **Imports**: Group by standard library, third-party, internal (blank lines between groups)
- **Injection**: Use constructor injection with interfaces
- **Versions**: Specify constraints in go.mod; document breaking changes

## Package Naming Conventions

- Use lowercase, descriptive names: `llms`, `vectorstores`, `embeddings`
- Avoid abbreviations unless widely understood (e.g., `llms` is acceptable)
- Use singular forms: `agent` not `agents`, `tool` not `tools`

## Extension Patterns

### Adding a New Provider
1. Create implementation in `providers/{provider_name}.go`
2. Implement the interface
3. Register in global registry: `RegisterGlobal("provider_name", NewProviderCreator)`
4. Add config options in `config.go`
5. Add tests in `advanced_test.go`

### Adding a New Agent Type
1. Define struct in `pkg/agents/providers/{agent_name}/`
2. Embed `BaseAgent`
3. Implement `Agent` interface
4. Register in factory

### Adding a New Vector Store
1. Create in `pkg/vectorstores/providers/{store_name}/`
2. Implement `VectorStore` interface
3. Add to factory in `vectorstores.go`

## References

- **Complete Details**: `docs/package_design_patterns.md`
- **Architecture**: `docs/architecture.md`
- **Testing Requirements**: See `beluga-test-standards.mdc`
- **Quality Requirements**: See `beluga-quality-standards.mdc`
- **Knowledge Base**: See `beluga-knowledge-base.mdc` for KB integration