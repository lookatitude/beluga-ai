package voice

import (
	"fmt"
	"sync"
	"time"
)

// SessionState represents the current state of a voice session.
type SessionState string

const (
	// StateIdle indicates the session is not actively processing audio.
	StateIdle SessionState = "idle"

	// StateListening indicates the session is receiving and processing user audio.
	StateListening SessionState = "listening"

	// StateSpeaking indicates the session is producing audio output.
	StateSpeaking SessionState = "speaking"
)

// Turn represents a single conversational exchange in a voice session.
type Turn struct {
	// ID uniquely identifies this turn within the session.
	ID string

	// UserText is the transcribed text from the user's speech.
	UserText string

	// AgentText is the text response generated by the agent.
	AgentText string

	// ToolCalls lists the tool call IDs made during this turn.
	ToolCalls []string

	// StartTime is when the turn began.
	StartTime time.Time

	// EndTime is when the turn completed. Zero value means still in progress.
	EndTime time.Time
}

// VoiceSession manages the state and conversational turns of a voice
// interaction. It is safe for concurrent use.
type VoiceSession struct {
	mu sync.RWMutex

	// ID uniquely identifies this session.
	ID string

	// State is the current session state (idle, listening, speaking).
	State SessionState

	// Turns holds all conversational turns in chronological order.
	Turns []Turn

	// CreatedAt is when the session was created.
	CreatedAt time.Time

	// Metadata holds arbitrary session-level metadata.
	Metadata map[string]any
}

// NewSession creates a new VoiceSession in the idle state.
func NewSession(id string) *VoiceSession {
	return &VoiceSession{
		ID:        id,
		State:     StateIdle,
		CreatedAt: time.Now(),
		Metadata:  make(map[string]any),
	}
}

// Transition moves the session to a new state. It returns an error if the
// transition is invalid:
//   - idle → listening (start receiving audio)
//   - listening → speaking (agent responds)
//   - speaking → listening (agent done, user speaks)
//   - speaking → idle (session pauses)
//   - listening → idle (session pauses)
//   - any → idle (reset)
func (s *VoiceSession) Transition(state SessionState) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	if !validTransition(s.State, state) {
		return fmt.Errorf("voice: invalid state transition from %s to %s", s.State, state)
	}
	s.State = state
	return nil
}

// CurrentState returns the current session state.
func (s *VoiceSession) CurrentState() SessionState {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.State
}

// AddTurn appends a turn to the session's history.
func (s *VoiceSession) AddTurn(turn Turn) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.Turns = append(s.Turns, turn)
}

// TurnCount returns the number of turns in the session.
func (s *VoiceSession) TurnCount() int {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return len(s.Turns)
}

// LastTurn returns the most recent turn, or nil if no turns exist.
func (s *VoiceSession) LastTurn() *Turn {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if len(s.Turns) == 0 {
		return nil
	}
	t := s.Turns[len(s.Turns)-1]
	return &t
}

// validTransition checks whether a state transition is allowed.
func validTransition(from, to SessionState) bool {
	// Transition to idle is always allowed (reset).
	if to == StateIdle {
		return true
	}
	switch from {
	case StateIdle:
		return to == StateListening
	case StateListening:
		return to == StateSpeaking
	case StateSpeaking:
		return to == StateListening
	default:
		return false
	}
}
