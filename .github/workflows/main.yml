name: Main

on:
  push:
    branches: [main]
    paths-ignore:
      - "CODE-QUALITY.md"
      - "SECURITY.md"
      - "CHANGELOG.md"
      - ".github/**"
      - ".claude/**"
      - "docs/website/**"

concurrency:
  group: "main-pipeline"
  cancel-in-progress: true

env:
  GO_VERSION: "1.25.7"
  NODE_VERSION: "22"

jobs:
  ci:
    name: CI Checks
    permissions:
      contents: read
    uses: ./.github/workflows/_ci-checks.yml

  security:
    name: Security Checks
    permissions:
      contents: read
      security-events: write
    uses: ./.github/workflows/_security-checks.yml
    secrets:
      SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

  sonarcloud:
    name: SonarCloud Analysis
    needs: ci
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download coverage
        uses: actions/download-artifact@v8
        with:
          name: coverage

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v7
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  generate-reports:
    name: Generate Reports
    needs: [ci, security]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: always()
    steps:
      - uses: actions/checkout@v6

      - name: Download coverage
        uses: actions/download-artifact@v8
        with:
          name: coverage
        continue-on-error: true

      - name: Generate CODE-QUALITY.md
        env:
          LINT_STATUS: ${{ needs.ci.outputs.lint_status }}
          LINT_ISSUES: ${{ needs.ci.outputs.lint_issues_count }}
          TEST_STATUS: ${{ needs.ci.outputs.test_status }}
          TEST_COUNT: ${{ needs.ci.outputs.test_count }}
          COVERAGE: ${{ needs.ci.outputs.coverage_pct }}
          INT_STATUS: ${{ needs.ci.outputs.integration_status }}
          INT_COUNT: ${{ needs.ci.outputs.integration_count }}
        run: |
          cat > CODE-QUALITY.md << 'HEADER'
          # Code Quality Report

          > Auto-generated by CI pipeline. Do not edit manually.

          HEADER

          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M UTC')
          echo "**Last updated:** ${TIMESTAMP}" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md

          # Linting section
          echo "## Linting" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md
          if [ "$LINT_STATUS" = "passing" ]; then
            echo "**Status:** Passing" >> CODE-QUALITY.md
          else
            echo "**Status:** Failing" >> CODE-QUALITY.md
          fi
          echo "**Issues found:** ${LINT_ISSUES:-0}" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md
          echo "**Linters enabled:** gosec, govet, staticcheck, errcheck, ineffassign, unused, gofmt, goimports, misspell, revive, bodyclose, noctx, gocritic" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md

          # Unit tests section
          echo "## Unit Tests" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md
          if [ "$TEST_STATUS" = "passing" ]; then
            echo "**Status:** Passing" >> CODE-QUALITY.md
          else
            echo "**Status:** Failing" >> CODE-QUALITY.md
          fi
          echo "**Total tests:** ${TEST_COUNT:-0}" >> CODE-QUALITY.md
          echo "**Coverage:** ${COVERAGE:-0}%" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md

          # Integration tests section
          echo "## Integration Tests" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md
          if [ "$INT_STATUS" = "passing" ]; then
            echo "**Status:** Passing" >> CODE-QUALITY.md
          else
            echo "**Status:** Failing" >> CODE-QUALITY.md
          fi
          echo "**Total tests:** ${INT_COUNT:-0}" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md

          # Build checks section
          echo "## Build Checks" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md
          echo "| Check | Status |" >> CODE-QUALITY.md
          echo "|-------|--------|" >> CODE-QUALITY.md
          echo "| go vet | Passing |" >> CODE-QUALITY.md
          echo "| go build | Passing |" >> CODE-QUALITY.md
          echo "| go mod tidy | Clean |" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md

          # SonarCloud link
          echo "## SonarCloud" >> CODE-QUALITY.md
          echo "" >> CODE-QUALITY.md
          echo "Full analysis available at [SonarCloud Dashboard](https://sonarcloud.io/project/overview?id=lookatitude_beluga-ai)" >> CODE-QUALITY.md

      - name: Generate SECURITY.md
        env:
          SNYK_STATUS: ${{ needs.security.outputs.snyk_status }}
          SNYK_VULNS: ${{ needs.security.outputs.snyk_vulns }}
          TRIVY_STATUS: ${{ needs.security.outputs.trivy_status }}
          TRIVY_FINDINGS: ${{ needs.security.outputs.trivy_findings }}
          GOVULNCHECK_STATUS: ${{ needs.security.outputs.govulncheck_status }}
          GOVULNCHECK_VULNS: ${{ needs.security.outputs.govulncheck_vulns }}
          GOSEC_STATUS: ${{ needs.security.outputs.gosec_status }}
          GITLEAKS_STATUS: ${{ needs.security.outputs.gitleaks_status }}
          LIC_STATUS: ${{ needs.security.outputs.licenses_status }}
          LIC_VIOLATIONS: ${{ needs.security.outputs.licenses_violations }}
        run: |
          cat > SECURITY.md << 'HEADER'
          # Security Report

          > Auto-generated by CI security pipeline. Do not edit manually.

          HEADER

          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M UTC')
          echo "**Last updated:** ${TIMESTAMP}" >> SECURITY.md
          echo "" >> SECURITY.md

          # Snyk section
          echo "## Dependency Vulnerabilities (Snyk)" >> SECURITY.md
          echo "" >> SECURITY.md
          if [ "$SNYK_STATUS" = "clean" ]; then
            echo "**Status:** No vulnerabilities found" >> SECURITY.md
          else
            echo "**Status:** ${SNYK_VULNS:-unknown} vulnerabilities found" >> SECURITY.md
          fi
          echo "" >> SECURITY.md
          echo "[View full Snyk report](https://app.snyk.io)" >> SECURITY.md
          echo "" >> SECURITY.md

          # Trivy section
          echo "## Dependency & Filesystem Scan (Trivy)" >> SECURITY.md
          echo "" >> SECURITY.md
          if [ "$TRIVY_STATUS" = "clean" ]; then
            echo "**Status:** No findings (CRITICAL/HIGH)" >> SECURITY.md
          else
            echo "**Status:** ${TRIVY_FINDINGS:-0} findings detected" >> SECURITY.md
          fi
          echo "" >> SECURITY.md
          echo "Results uploaded to [GitHub Security tab](../../security/code-scanning)" >> SECURITY.md
          echo "" >> SECURITY.md

          # govulncheck section
          echo "## Go Vulnerability Database (govulncheck)" >> SECURITY.md
          echo "" >> SECURITY.md
          if [ "$GOVULNCHECK_STATUS" = "clean" ]; then
            echo "**Status:** No vulnerabilities found" >> SECURITY.md
          else
            echo "**Status:** ${GOVULNCHECK_VULNS:-unknown} vulnerabilities found" >> SECURITY.md
          fi
          echo "" >> SECURITY.md
          echo "Scanned using the Go team's official vulnerability scanner with symbol-level reachability analysis." >> SECURITY.md
          echo "" >> SECURITY.md
          echo "[Go Vulnerability Database](https://vuln.go.dev)" >> SECURITY.md
          echo "" >> SECURITY.md

          # gosec section
          echo "## Static Security Analysis (gosec)" >> SECURITY.md
          echo "" >> SECURITY.md
          if [ "$GOSEC_STATUS" = "clean" ]; then
            echo "**Status:** No findings" >> SECURITY.md
          else
            echo "**Status:** Findings detected — review required" >> SECURITY.md
          fi
          echo "" >> SECURITY.md
          echo "SARIF results uploaded to [GitHub Security tab](../../security/code-scanning)" >> SECURITY.md
          echo "" >> SECURITY.md

          # Gitleaks section
          echo "## Secret Detection (Gitleaks)" >> SECURITY.md
          echo "" >> SECURITY.md
          if [ "$GITLEAKS_STATUS" = "clean" ]; then
            echo "**Status:** No secrets detected" >> SECURITY.md
          else
            echo "**Status:** Potential secrets detected — review required" >> SECURITY.md
          fi
          echo "" >> SECURITY.md

          # License compliance section
          echo "## License Compliance (go-licenses)" >> SECURITY.md
          echo "" >> SECURITY.md
          if [ "$LIC_STATUS" = "compliant" ]; then
            echo "**Status:** All dependencies compliant" >> SECURITY.md
          else
            echo "**Status:** ${LIC_VIOLATIONS:-0} license violations found" >> SECURITY.md
          fi
          echo "" >> SECURITY.md
          echo "**Allowed licenses:** MIT, Apache-2.0, BSD-2-Clause, BSD-3-Clause, ISC, MPL-2.0" >> SECURITY.md
          echo "" >> SECURITY.md

          # CodeQL note
          echo "## Static Analysis (CodeQL)" >> SECURITY.md
          echo "" >> SECURITY.md
          echo "CodeQL runs in a [separate workflow](../../actions/workflows/codeql.yml). Results are available in the [GitHub Security tab](../../security/code-scanning)." >> SECURITY.md
          echo "" >> SECURITY.md

          # Summary
          echo "---" >> SECURITY.md
          echo "" >> SECURITY.md
          echo "## Reporting Vulnerabilities" >> SECURITY.md
          echo "" >> SECURITY.md
          echo "If you discover a security vulnerability, please report it responsibly by emailing security@lookatitude.com. Do not open public issues for security vulnerabilities." >> SECURITY.md

      - name: Upload reports artifact
        uses: actions/upload-artifact@v4
        with:
          name: reports
          path: |
            CODE-QUALITY.md
            SECURITY.md

  godoc:
    name: Generate GoDoc
    needs: [ci]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6

      - uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install pkgsite
        run: go install golang.org/x/pkgsite/cmd/pkgsite@latest

      - name: Generate godoc HTML
        run: |
          mkdir -p godoc-output

          pkgsite -http=:8080 . &
          PKGSITE_PID=$!

          echo "Waiting for pkgsite to start..."
          for i in $(seq 1 60); do
            if curl -sf http://localhost:8080/ > /dev/null 2>&1; then
              echo "pkgsite ready after ${i}s"
              break
            fi
            if [ "$i" -eq 60 ]; then
              echo "ERROR: pkgsite failed to start after 60s"
              kill $PKGSITE_PID 2>/dev/null || true
              exit 1
            fi
            sleep 1
          done

          wget --mirror --convert-links --adjust-extension \
            --page-requisites --no-parent \
            --directory-prefix=godoc-output \
            --no-host-directories \
            --reject="robots.txt" \
            --reject-regex '.*\?.*' \
            --tries=3 --retry-connrefused \
            "http://localhost:8080/github.com/lookatitude/beluga-ai" 2>&1 || true

          kill $PKGSITE_PID 2>/dev/null || true

          find godoc-output -name '*[?*:<>"|]*' -delete 2>/dev/null || true

          FILE_COUNT=$(find godoc-output -type f | wc -l)
          echo "Generated ${FILE_COUNT} godoc files"

      - name: Upload godoc artifact
        uses: actions/upload-artifact@v4
        with:
          name: godoc
          path: godoc-output/
          if-no-files-found: warn

  build-website:
    name: Build Website
    needs: [godoc, generate-reports]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6

      - uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "yarn"
          cache-dependency-path: docs/website/yarn.lock

      - name: Download godoc artifact
        uses: actions/download-artifact@v8
        continue-on-error: true
        with:
          name: godoc
          path: docs/website/public/godoc/

      - name: Download reports artifact
        uses: actions/download-artifact@v8
        with:
          name: reports
          path: /tmp/reports/

      - name: Copy reports into Astro content
        working-directory: docs/website
        run: |
          mkdir -p src/content/docs/reports

          for f in CHANGELOG.md SECURITY.md CODE-QUALITY.md; do
            # Try reports artifact first, then repo root
            if [ -f "/tmp/reports/$f" ]; then
              SOURCE="/tmp/reports/$f"
            elif [ -f "../../$f" ]; then
              SOURCE="../../$f"
            else
              echo "Skipping $f (not found)"
              continue
            fi

            slug=$(basename "$f" .md | tr '[:upper:]' '[:lower:]' | tr '_' '-')

            case "$slug" in
              changelog) title="Changelog" ;;
              security) title="Security" ;;
              code-quality) title="Code Quality" ;;
              *) title="$slug" ;;
            esac

            echo "---" > "src/content/docs/reports/${slug}.md"
            echo "title: ${title}" >> "src/content/docs/reports/${slug}.md"
            echo "---" >> "src/content/docs/reports/${slug}.md"
            echo "" >> "src/content/docs/reports/${slug}.md"
            cat "$SOURCE" >> "src/content/docs/reports/${slug}.md"

            echo "Copied $f -> reports/${slug}.md"
          done

      - name: Install dependencies
        working-directory: docs/website
        run: yarn install --frozen-lockfile

      - name: Build Astro site
        working-directory: docs/website
        run: yarn build

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: docs/website/dist/

  deploy:
    name: Deploy to GitHub Pages
    needs: build-website
    runs-on: ubuntu-latest
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  commit-reports:
    name: Commit Generated Reports
    needs: [generate-reports, deploy]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v6

      - name: Download reports artifact
        uses: actions/download-artifact@v8
        with:
          name: reports

      - name: Create PR for report updates
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ci/update-reports
          base: main
          delete-branch: true
          title: "chore(ci): update CODE-QUALITY.md and SECURITY.md"
          commit-message: "chore(ci): update CODE-QUALITY.md and SECURITY.md [skip ci]"
          body: |
            Auto-generated report updates from the main CI pipeline.

            - Update `CODE-QUALITY.md`
            - Update `SECURITY.md`
          add-paths: |
            CODE-QUALITY.md
            SECURITY.md

  # After main passes CI and security, compute next version from conventional
  # commits since the last tag: minor for feat, patch otherwise.
  # Breaking changes (feat!:, fix!:, BREAKING CHANGE) skip auto-release;
  # major versions must be published manually via the Release workflow.
  # The pushed tag triggers .github/workflows/release.yml.
  release-tag:
    name: Bump Version and Create Release Tag
    needs: [ci, security]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Compute next version from conventional commits
        id: bump
        run: |
          set -e

          # ── 1. Resolve latest tag ──────────────────────────────────────
          LATEST=$(git tag -l 'v*.*.*' --sort=-v:refname | head -1 || true)

          if [ -z "$LATEST" ]; then
            echo "No existing tag found; starting at v0.0.1"
            echo "tag=v0.0.1" >> "$GITHUB_OUTPUT"
            echo "skip=false"  >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Latest tag: ${LATEST}"

          # ── 2. Skip if HEAD is already tagged ──────────────────────────
          if git describe --exact-match --tags HEAD 2>/dev/null; then
            echo "HEAD is already tagged — skipping auto-release."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # ── 3. Parse latest tag into MAJOR.MINOR.PATCH ────────────────
          V="${LATEST#v}"
          MAJOR="${V%%.*}"
          REST="${V#*.}"
          MINOR="${REST%%.*}"
          PATCH="${REST#*.}"

          # ── 4. Collect commit subjects + bodies since last tag ─────────
          HAS_BREAKING=false
          HAS_FEAT=false

          # Use NUL-delimited records so multi-line bodies are safe.
          # Format: subject<NUL>body<NUL>  (repeated per commit)
          while IFS= read -r -d '' SUBJECT && IFS= read -r -d '' BODY; do
            # 4a. Check for breaking change indicator in the subject
            #     Matches: feat!:  fix(scope)!:  refactor!:  etc.
            if echo "$SUBJECT" | grep -qE '^[a-z]+(\([^)]*\))?!:'; then
              echo "  BREAKING (subject): ${SUBJECT}"
              HAS_BREAKING=true
            fi

            # 4b. Check for BREAKING CHANGE token in the body
            if echo "$BODY" | grep -qi 'BREAKING CHANGE'; then
              echo "  BREAKING (body): ${SUBJECT}"
              HAS_BREAKING=true
            fi

            # 4c. Check for feat (without breaking bang)
            if echo "$SUBJECT" | grep -qE '^feat(\([^)]*\))?:'; then
              echo "  feat: ${SUBJECT}"
              HAS_FEAT=true
            fi
          done < <(git log "${LATEST}..HEAD" --pretty=format:"%s%x00%b%x00")

          # ── 5. Decide bump ─────────────────────────────────────────────
          if [ "$HAS_BREAKING" = true ]; then
            echo "Breaking changes detected — skipping auto-release."
            echo "Major releases must be published manually via the Release workflow."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$HAS_FEAT" = true ]; then
            NEW_TAG="v${MAJOR}.$((MINOR + 1)).0"
            echo "feat detected → minor bump: ${LATEST} -> ${NEW_TAG}"
          else
            NEW_TAG="v${MAJOR}.${MINOR}.$((PATCH + 1))"
            echo "No feat → patch bump: ${LATEST} -> ${NEW_TAG}"
          fi

          echo "tag=${NEW_TAG}" >> "$GITHUB_OUTPUT"
          echo "skip=false"     >> "$GITHUB_OUTPUT"

      - name: Create and push tag
        if: steps.bump.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "${{ steps.bump.outputs.tag }}"
          git push origin "${{ steps.bump.outputs.tag }}"
