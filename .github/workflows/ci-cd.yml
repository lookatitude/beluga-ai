# CI/CD Workflow
# Runs on all pull requests and pushes to main/develop branches
# Includes: policy checks, linting, security scans, unit tests, integration tests, coverage, and build verification
# Critical checks (block merge): unit-tests, security, build
# Advisory checks (warnings only): lint, coverage threshold

name: CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      run_policy:
        description: 'Run policy checks'
        required: false
        default: false
        type: boolean
      run_lint:
        description: 'Run lint and format checks'
        required: false
        default: false
        type: boolean
      run_security:
        description: 'Run security scans'
        required: false
        default: false
        type: boolean
      run_unit_tests:
        description: 'Run unit tests'
        required: false
        default: false
        type: boolean
      run_integration_tests:
        description: 'Run integration tests'
        required: false
        default: false
        type: boolean
      run_build:
        description: 'Run build verification'
        required: false
        default: false
        type: boolean

env:
  GO_VERSION: '1.24'

jobs:
  # ============================================================================
  # POLICY CHECKS (PR only) - ADVISORY (warnings only, doesn't block merge)
  # ============================================================================
  policy:
    name: ðŸ“‹ Policy Checks
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'pull_request') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.run_policy == 'true')
    continue-on-error: true  # Advisory check - warnings don't block merge
    steps:
      - uses: actions/checkout@v6
      
      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
      
      - name: Validate branch name (###-kebab-case)
        run: |
          BRANCH="${GITHUB_HEAD_REF}"
          if ! echo "$BRANCH" | grep -Eq '^[0-9]{3}-[a-z0-9-]+$'; then
            echo "::warning::Branch name must be ###-kebab-case"
            echo "âŒ Branch name must be ###-kebab-case"
          else
            echo "âœ… Branch name is valid"
          fi
      
      - name: Enforce PR description contains spec link
        run: |
          body=$(jq -r '.pull_request.body' "$GITHUB_EVENT_PATH")
          if ! echo "$body" | grep -Eq '(Spec:|/specs/|Feature Spec|Mini-spec)'; then
            echo "::warning::PR body must link a spec or include mini-spec"
            echo "âŒ PR body must link a spec or include mini-spec"
          else
            echo "âœ… PR description contains spec reference"
          fi
      
      - name: Check PR size
        run: |
          added=$(jq '.pull_request.additions' "$GITHUB_EVENT_PATH")
          removed=$(jq '.pull_request.deletions' "$GITHUB_EVENT_PATH")
          lines=$((added+removed))
          echo "ðŸ“Š PR size: $lines lines"
          if [ "$lines" -gt 1500 ]; then
            echo "::warning::âŒ PR too large (>1500 lines). Add label 'large-pr' to proceed"
          fi
          if [ "$lines" -gt 600 ]; then
            echo "::warning::âš ï¸  Large PR (>600 lines). Consider splitting"
          fi

  # ============================================================================
  # CODE QUALITY (ADVISORY - warnings only, doesn't block merge)
  # ============================================================================
  lint:
    name: ðŸ” Lint & Format
    runs-on: ubuntu-latest
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.run_lint == 'true'
    continue-on-error: true  # Advisory check - warnings don't block merge
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Install golangci-lint
        run: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.6.2
          export PATH="$PATH:$(go env GOPATH)/bin"
          golangci-lint --version
      
      - name: golangci-lint (with auto-fix)
        run: |
          # Workaround: Exclude react package to avoid printf linter panic bug in golangci-lint v2.6.2
          # Bug: interface conversion: types.Object is nil, not *types.Var in printf analyzer
          export PATH="$PATH:$(go env GOPATH)/bin"
          
          echo "Filtering packages to exclude react package (workaround for golangci-lint v2.6.2 bug)..."
          
          # Get all packages and filter out react (using full import path)
          all_packages=$(go list ./pkg/... ./tests/... 2>/dev/null)
          filtered_packages=$(echo "$all_packages" | grep -v "github.com/lookatitude/beluga-ai/pkg/agents/providers/react$" | sed 's|^github.com/lookatitude/beluga-ai/||')
          
          if [ -z "$filtered_packages" ]; then
            echo "Error: Could not determine packages to lint after filtering"
            exit 1
          fi
          
          echo "Linting packages (excluding react due to printf panic bug):"
          echo "$filtered_packages" | head -10
          echo "..."
          echo ""
          
          # Verify react package is excluded
          if echo "$filtered_packages" | grep -q "react"; then
            echo "ERROR: react package still in filtered list!"
            exit 1
          fi
          
          # Run golangci-lint on each package individually to avoid react package panic
          # The react package causes a panic in golangci-lint v2.6.2, so we must exclude it
          failed=0
          total=0
          while IFS= read -r pkg; do
            if [ -n "$pkg" ] && [ "$pkg" != "pkg/agents/providers/react" ]; then
              total=$((total + 1))
              echo "Linting ./$pkg..."
              golangci-lint run --timeout=5m --fix "./$pkg" 2>&1 | tee /tmp/lint-$total.log
              # Capture exit status of golangci-lint (first command in pipeline), not tee
              lint_status=${PIPESTATUS[0]}
              if [ "$lint_status" -ne 0 ]; then
                failed=$((failed + 1))
                echo "::warning::Linting failed for ./$pkg (advisory - does not block merge)"
              fi
            fi
          done <<< "$filtered_packages"
          
          echo ""
          echo "Linting summary: $failed failed out of $total packages"
          # Note: This is an advisory check (continue-on-error: true), so we always exit 0
          exit 0
      
      - name: go vet
        run: |
          echo "Running go vet..."
          go vet ./pkg/... ./cmd/... ./tests/... 2>&1 | tee vet-report.txt
          vet_status=${PIPESTATUS[0]}
          if [ "$vet_status" -ne 0 ]; then
            echo "::warning::go vet found issues (advisory - does not block merge)"
            cat vet-report.txt
            exit 1
          fi
          echo "âœ… go vet passed - no issues found"
      
      - name: go fmt (auto-fix)
        run: |
          echo "Auto-formatting code with gofmt..."
          gofmt -w -s .
          echo "âœ… Code formatted with gofmt"
      
      - name: Commit auto-fixed files
        if: github.event_name == 'pull_request'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: auto-fix linting and formatting issues [skip ci]" || {
              echo "::warning::Failed to commit auto-fixed files (advisory - does not block merge)"
              exit 0
            }
            git push || {
              echo "::warning::Failed to push auto-fixed files (advisory - does not block merge)"
              exit 0
            }
            echo "âœ… Auto-fixed files committed to PR branch"
          fi
      
      - name: Validate package declarations
        run: |
          echo "Validating all .go files have package declarations..."
          failed=0
          missing_packages=""
          
          while IFS= read -r file; do
            # Skip test files in specs and examples
            if [[ "$file" =~ (specs|examples) ]]; then
              continue
            fi
            
            # Check if file has package declaration (may be after comments)
            # Look for "package " in first 100 lines to handle files with very long package comments
            if ! head -n 100 "$file" 2>/dev/null | grep -q "^package "; then
              echo "::error file=$file::Missing package declaration"
              missing_packages="${missing_packages}${file}\n"
              failed=1
            fi
          done < <(find . -name "*.go" -type f | grep -v -E '(specs|examples|vendor)')
          
          if [ "$failed" -eq 1 ]; then
            echo "âŒ Some files are missing package declarations:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo -e "$missing_packages" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "::error::Some .go files are missing package declarations"
            exit 1
          fi
          
          echo "âœ… All .go files have package declarations" >> $GITHUB_STEP_SUMMARY
          echo "âœ… All .go files have package declarations"
      
      - name: Generate Lint Summary
        if: always()
        run: |
          echo "## ðŸ” Lint & Format Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f vet-report.txt ] && [ -s vet-report.txt ]; then
            echo "### âš ï¸ go vet Issues" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat vet-report.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… **go vet**: No issues found" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **golangci-lint**: See annotations above" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **go fmt**: All files properly formatted" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # SECURITY SCANS (CRITICAL - blocks merge on failure)
  # ============================================================================
  security:
    name: ðŸ”’ Security Scans
    runs-on: ubuntu-latest
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.run_security == 'true'
    # Critical check - failures block merge
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Run gosec (code security)
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          echo "Running gosec security scan..."
          mkdir -p coverage
          # Exclude acceptable security rules:
          # G101: Hardcoded credentials (false positives in config files)
          # G201: SQL string formatting (table names are safe, not user input)
          # G204: Subprocess launch (intentional for shell tool and test runner)
          # G304: File inclusion (file paths from code analysis, not user input)
          # G404: Weak random (acceptable in test/mock files)
          gosec -fmt=json -out=coverage/gosec-report.json -exclude=G101,G201,G204,G304,G404 ./pkg/... ./cmd/... ./tests/... || true
          gosec -fmt=text -exclude=G101,G201,G204,G304,G404 ./pkg/... ./cmd/... ./tests/... 2>&1 | tee coverage/gosec-report.txt
          
          # Check if any issues were found
          if grep -q "Issues : [1-9]" coverage/gosec-report.txt; then
            echo "::error::Security issues found by gosec"
            exit 1
          fi
          echo "âœ… No security issues found"
      
      - name: Run govulncheck (vulnerability scanning)
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          echo "Running govulncheck vulnerability scan..."
          govulncheck ./pkg/... ./cmd/... ./tests/... 2>&1 | tee coverage/govulncheck-report.txt || true
          echo "âœ… Vulnerability scan completed"
      
      - name: Run gitleaks (secret detection)
        run: |
          # Install gitleaks
          wget -q https://github.com/gitleaks/gitleaks/releases/download/v8.18.0/gitleaks_8.18.0_linux_x64.tar.gz
          tar -xzf gitleaks_8.18.0_linux_x64.tar.gz
          chmod +x gitleaks
          
          echo "Running gitleaks secret detection..."
          ./gitleaks detect --no-banner --redact --config=.gitleaks.toml --report-path=coverage/gitleaks-report.json || true
          
          # Check results
          if [ -f coverage/gitleaks-report.json ] && [ -s coverage/gitleaks-report.json ] && [ "$(cat coverage/gitleaks-report.json)" != "[]" ]; then
            echo "::error::Secrets detected by gitleaks"
            ./gitleaks detect --no-banner --redact --config=.gitleaks.toml
            exit 1
          fi
          echo "âœ… No secrets detected"
      
      - name: Run Trivy (file system scan)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'coverage/trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          skip-dirs: 'specs,examples,docs,website'
        continue-on-error: true
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: coverage/trivy-results.sarif
          wait-for-processing: true
      
      - name: Generate Security Summary
        if: always()
        run: |
          echo "## ðŸ”’ Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # gosec summary
          if [ -f coverage/gosec-report.txt ]; then
            issues=$(grep -oP "Issues : \K\d+" coverage/gosec-report.txt || echo "0")
            if [ "$issues" -gt 0 ]; then
              echo "### âŒ gosec: Found $issues security issue(s)" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              tail -20 coverage/gosec-report.txt >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **gosec**: No security issues found" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # govulncheck summary
          if [ -f coverage/govulncheck-report.txt ]; then
            vulns=$(grep -c "Vulnerable" coverage/govulncheck-report.txt 2>/dev/null || echo "0")
            if [ "$vulns" -gt 0 ]; then
              echo "### âš ï¸ govulncheck: Found $vulns vulnerability(ies)" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              tail -20 coverage/govulncheck-report.txt >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **govulncheck**: No vulnerabilities found" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # gitleaks summary
          if [ -f coverage/gitleaks-report.json ]; then
            leaks=$(cat coverage/gitleaks-report.json | grep -o "RuleID" | wc -l || echo "0")
            if [ "$leaks" -gt 0 ]; then
              echo "### âŒ gitleaks: Found $leaks potential secret(s)" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **gitleaks**: No secrets detected" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Trivy**: Results uploaded to GitHub Security tab" >> $GITHUB_STEP_SUMMARY
      
      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: security-reports
          path: |
            coverage/gosec-report.json
            coverage/gosec-report.txt
            coverage/govulncheck-report.txt
            coverage/gitleaks-report.json
            coverage/trivy-results.sarif
          retention-days: 30

  # ============================================================================
  # UNIT TESTS (CRITICAL - blocks merge on failure)
  # ============================================================================
  unit-tests:
    name: ðŸ§ª Unit Tests
    runs-on: ubuntu-latest
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.run_unit_tests == 'true'
    # Critical check - failures block merge
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run unit tests
        run: |
          echo "Running unit tests..."
          # Run tests with coverage, excluding integration tests
          # Use set +e to continue even if some tests fail, ensuring coverage file is generated
          set +e
          go test -v -race -coverprofile=coverage.unit.out -covermode=atomic ./pkg/... 2>&1 | tee test-output.txt
          test_exit_code=$?
          set -e
          
          # Ensure coverage file exists (create empty if tests completely failed)
          if [ ! -f coverage.unit.out ]; then
            echo "âš ï¸  Coverage file not generated, creating empty file"
            touch coverage.unit.out
          fi
          
          # Validate coverage file is not empty and is valid
          if [ ! -s coverage.unit.out ]; then
            echo "âš ï¸  Coverage file is empty"
          else
            # Validate file format by attempting to parse it
            if ! go tool cover -func=coverage.unit.out > /dev/null 2>&1; then
              echo "âš ï¸  Coverage file format invalid"
            fi
          fi
          
          # Also run with JSON output (without coverage to avoid file conflicts)
          go test -v -race -json ./pkg/... 2>&1 > test-output.json || true
          
          # Exit with test exit code to preserve test failure status
          exit $test_exit_code
      
      - name: Parse test results
        if: always()
        id: test_results
        run: |
          set +e  # Don't exit on error
          
          # Count package-level results
          passed=$(grep -c "^ok  " test-output.txt 2>/dev/null || echo "0")
          failed=$(grep -c "^FAIL" test-output.txt 2>/dev/null || echo "0")
          
          # Clean up the values (remove any whitespace/newlines)
          passed=$(echo "$passed" | tr -d '\n\r' | tr -d ' ')
          failed=$(echo "$failed" | tr -d '\n\r' | tr -d ' ')
          
          # Ensure they're numbers
          if ! [[ "$passed" =~ ^[0-9]+$ ]]; then passed=0; fi
          if ! [[ "$failed" =~ ^[0-9]+$ ]]; then failed=0; fi
          
          # Calculate total
          total=$((passed + failed))
          
          echo "passed=$passed" >> $GITHUB_OUTPUT
          echo "failed=$failed" >> $GITHUB_OUTPUT
          echo "total=$total" >> $GITHUB_OUTPUT
          
          # Calculate coverage
          if [ -f coverage.unit.out ] && [ -s coverage.unit.out ]; then
            # Validate coverage file can be parsed
            if go tool cover -func=coverage.unit.out > /dev/null 2>&1; then
              coverage=$(go tool cover -func=coverage.unit.out 2>/dev/null | grep total | awk '{print $3}' || echo "")
              if [ -n "$coverage" ] && [ "$coverage" != "0%" ]; then
                coverage_num=$(echo "$coverage" | sed 's/%//' | tr -d '\n\r' | tr -d ' ')
                if [[ "$coverage_num" =~ ^[0-9.]+$ ]]; then
                  echo "coverage=$coverage" >> $GITHUB_OUTPUT
                  echo "coverage_num=$coverage_num" >> $GITHUB_OUTPUT
                  echo "âœ… Coverage calculated: $coverage"
                else
                  echo "âš ï¸  Invalid coverage number format: $coverage_num"
                  echo "coverage=0%" >> $GITHUB_OUTPUT
                  echo "coverage_num=0" >> $GITHUB_OUTPUT
                fi
              else
                echo "âš ï¸  Coverage parsing returned empty or 0%"
                echo "coverage=0%" >> $GITHUB_OUTPUT
                echo "coverage_num=0" >> $GITHUB_OUTPUT
              fi
            else
              echo "âš ï¸  Coverage file exists but is not valid Go coverage format"
              echo "coverage=0%" >> $GITHUB_OUTPUT
              echo "coverage_num=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸  Coverage file missing or empty"
            echo "coverage=0%" >> $GITHUB_OUTPUT
            echo "coverage_num=0" >> $GITHUB_OUTPUT
          fi
          
          echo "ðŸ“Š Test Results: $passed passed, $failed failed out of $total tests"
          
          set -e  # Re-enable exit on error
      
      - name: Generate Test Summary
        if: always()
        run: |
          echo "## ðŸ§ª Unit Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Test Statistics:**" >> $GITHUB_STEP_SUMMARY
          echo "- Total tests: ${{ steps.test_results.outputs.total }}" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Passed: ${{ steps.test_results.outputs.passed }}" >> $GITHUB_STEP_SUMMARY
          echo "- âŒ Failed: ${{ steps.test_results.outputs.failed }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“ˆ Coverage: ${{ steps.test_results.outputs.coverage }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.test_results.outputs.failed }}" != "0" ]; then
            echo "### âŒ Failed Tests:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -A 10 "FAIL:" test-output.txt | head -50 >> $GITHUB_STEP_SUMMARY || true
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… **All tests passed!**" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Coverage breakdown
          if [ -f coverage.unit.out ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“ˆ Coverage by Package:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            go tool cover -func=coverage.unit.out | grep -v "total:" | tail -20 >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            go tool cover -func=coverage.unit.out | grep "total:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Check coverage threshold
        if: always()
        run: |
          coverage_num="${{ steps.test_results.outputs.coverage_num }}"
          coverage="${{ steps.test_results.outputs.coverage }}"
          
          if [ -z "$coverage_num" ] || [ "$coverage_num" = "0" ]; then
            echo "::warning::Coverage calculation failed or returned 0%. Please check test execution and coverage file generation."
          else
            # Coverage threshold is advisory - show warning but don't block
            if awk "BEGIN {exit !($coverage_num < 80)}"; then
              echo "::warning::Coverage ${coverage} is below 80% threshold (required: â‰¥80%) - advisory check"
              echo "Current coverage: ${coverage}"
              echo "Required coverage: 80%"
              echo "âš ï¸  Coverage below threshold, but this is an advisory check and does not block merge"
            else
              echo "âœ… Coverage ${coverage} meets 80% threshold"
            fi
          fi
      
      - name: Upload unit test coverage
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.unit.out
          flags: unittests
          name: unit-tests
        continue-on-error: true
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: unit-test-results
          path: |
            test-output.txt
            test-output.json
            coverage.unit.out
          retention-days: 30

  # ============================================================================
  # INTEGRATION TESTS
  # ============================================================================
  integration-tests:
    name: ðŸ”— Integration Tests
    runs-on: ubuntu-latest
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.run_integration_tests == 'true'
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run integration tests
        env:
          # Integration tests use mocks by default, but can use real providers if keys are set
          INTEGRATION_TEST_REAL_PROVIDERS: false
        run: |
          echo "Running integration tests..."
          go test -v -race -coverprofile=coverage.integration.out -covermode=atomic -timeout=15m ./tests/integration/... 2>&1 | tee integration-test-output.txt
          
          echo "ðŸ“Š Integration Test Coverage:"
          go tool cover -func=coverage.integration.out | tail -n1
      
      - name: Check integration test coverage threshold
        if: always()
        run: |
          if [ -f coverage.integration.out ] && [ -s coverage.integration.out ]; then
            coverage=$(go tool cover -func=coverage.integration.out 2>/dev/null | grep total | awk '{print $3}' || echo "")
            if [ -n "$coverage" ] && [ "$coverage" != "0%" ]; then
              coverage_num=$(echo "$coverage" | sed 's/%//' | tr -d '\n\r' | tr -d ' ')
              if [[ "$coverage_num" =~ ^[0-9.]+$ ]]; then
                # Coverage threshold is advisory - show warning but don't block
                if awk "BEGIN {exit !($coverage_num < 80)}"; then
                  echo "::warning::Integration test coverage ${coverage} is below 80% threshold (required: â‰¥80%) - advisory check"
                  echo "Current coverage: ${coverage}"
                  echo "Required coverage: 80%"
                  echo "âš ï¸  Coverage below threshold, but this is an advisory check and does not block merge"
                else
                  echo "âœ… Integration test coverage ${coverage} meets 80% threshold"
                fi
              fi
            fi
          else
            echo "::warning::Integration test coverage file missing or empty"
          fi
      
      - name: Upload integration test coverage
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.integration.out
          flags: integration
          name: integration-tests
        continue-on-error: true
      
      - name: Upload integration test results
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: integration-test-results
          path: |
            integration-test-output.txt
            coverage.integration.out
          retention-days: 30

  # ============================================================================
  # COVERAGE ENFORCEMENT (ADVISORY - warnings only, doesn't block merge)
  # ============================================================================
  coverage:
    name: ðŸ“ˆ Coverage Check (â‰¥80%)
    runs-on: ubuntu-latest
    continue-on-error: true  # Advisory check - warnings don't block merge
    needs: [unit-tests, integration-tests]
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Download unit test coverage
        uses: actions/download-artifact@v4
        with:
          name: unit-test-results
          path: coverage/
      
      - name: Download integration test coverage
        uses: actions/download-artifact@v4
        with:
          name: integration-test-results
          path: coverage/
      
      - name: Merge coverage reports
        run: |
          # Merge coverage files if both exist
          if [ -f coverage/coverage.unit.out ] && [ -f coverage/coverage.integration.out ]; then
            echo "mode: atomic" > coverage.out
            grep -h -v "^mode:" coverage/coverage.unit.out coverage/coverage.integration.out >> coverage.out || true
          elif [ -f coverage/coverage.unit.out ]; then
            cp coverage/coverage.unit.out coverage.out
          elif [ -f coverage/coverage.integration.out ]; then
            cp coverage/coverage.integration.out coverage.out
          else
            echo "No coverage files found"
            exit 1
          fi
      
      - name: Run tests and check coverage
        run: |
          # If merged coverage doesn't exist, generate it
          if [ ! -f coverage.out ]; then
            go test -coverprofile=coverage.out -covermode=atomic ./pkg/... ./cmd/... ./tests/... > /dev/null 2>&1
          fi
          
          pct=$(go tool cover -func=coverage.out | tail -n1 | awk '{print $3}' | sed 's/%//')
          echo "ðŸ“Š Total Coverage: ${pct}%"
          
          # Coverage threshold is advisory - show warning but don't block
          if awk "BEGIN {exit !($pct < 80)}"; then
            echo "::warning::Coverage ${pct}% is below 80% threshold (required: â‰¥80%) - advisory check"
            echo "Current coverage: ${pct}%"
            echo "Required coverage: 80%"
            echo "âš ï¸  Coverage below threshold, but this is an advisory check and does not block merge"
          else
            echo "âœ… Coverage ${pct}% meets minimum requirement"
          fi
      
      - name: Generate coverage report
        run: |
          echo "## ðŸ“ˆ Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          go tool cover -func=coverage.out >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
      
      - name: Upload merged coverage
        uses: actions/upload-artifact@v5
        with:
          name: merged-coverage
          path: coverage.out
          retention-days: 30

  # ============================================================================
  # BUILD (CRITICAL - blocks merge on failure)
  # ============================================================================
  build:
    name: ðŸ”¨ Build Packages
    runs-on: ubuntu-latest
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.run_build == 'true'
    # Critical check - failures block merge
    # Depends on critical jobs (security, unit-tests) but not advisory jobs (policy, lint)
    needs: [security, unit-tests]
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Download dependencies
        run: go mod download
      
      - name: Verify dependencies
        run: go mod verify
      
      - name: Build all packages
        run: |
          echo "Building all packages..."
          # Build packages using relative paths
          set +e
          go build -v ./pkg/... ./cmd/...
          build_exit=$?
          set -e
          
          if [ "$build_exit" -ne 0 ]; then
            echo "::error::Some packages failed to build"
            exit 1
          fi
          
          echo "âœ… All packages built successfully"
      
      - name: Verify build artifacts
        run: |
          echo "## ðŸ”¨ Build Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… All packages compiled successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Built Packages:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          go list ./pkg/... ./cmd/... >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # PACKAGE VERIFICATION
  # ============================================================================
  package:
    name: ðŸ“¦ Package Verification
    runs-on: ubuntu-latest
    needs: [build, integration-tests, coverage]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    steps:
      - uses: actions/checkout@v6
      
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: go.sum
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-
      
      - name: Verify module can be imported
        run: |
          echo "Verifying module can be imported..."
          go list -m -json github.com/lookatitude/beluga-ai
          echo "âœ… Module is valid and can be imported"
      
      - name: Generate package summary
        run: |
          echo "## ðŸ“¦ Package Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Module verified and ready for distribution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Module Info:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          go list -m -f '{{.Path}}@{{.Version}}' github.com/lookatitude/beluga-ai >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
      
      - name: Upload build verification
        uses: actions/upload-artifact@v5
        with:
          name: package-verification
          path: |
            go.mod
            go.sum
          retention-days: 7

  # ============================================================================
  # CI SUMMARY
  # ============================================================================
  ci-summary:
    name: âœ… CI Summary
    runs-on: ubuntu-latest
    needs: [lint, security, unit-tests, integration-tests, coverage, build, package]
    if: always()
    steps:
      - name: Generate CI Summary
        run: |
          echo "## âœ… CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All CI/CD checks have completed. Check individual job results for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Jobs Completed:" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“‹ Policy Checks" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ” Lint & Format" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”’ Security Scans" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ§ª Unit Tests" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”— Integration Tests" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“ˆ Coverage Check" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”¨ Build" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“¦ Package Verification" >> $GITHUB_STEP_SUMMARY

