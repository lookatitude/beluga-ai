// Package prompts provides interfaces and implementations for creating and formatting
// prompts to be sent to language models.
package prompts

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"text/template"

	"github.com/lookatitude/beluga-ai/core"
	"github.com/lookatitude/beluga-ai/schema"
)

// PromptValue represents the formatted output of a prompt template.
// It serves as an intermediate representation that can be easily converted
// into either a raw string or a structured list of messages, depending on the
// requirements of the language model being used.
type PromptValue interface {
	// ToString returns the prompt as a single string.
	ToString() string
	// ToMessages returns the prompt as a slice of schema.Message objects.
	ToMessages() []schema.Message
}

// StringPromptValue holds a simple string output from a template.
// This is typically used for completion-style LLMs.
type StringPromptValue struct {
	Value string
}

// ToString implements the PromptValue interface.
func (spv StringPromptValue) ToString() string {
	return spv.Value
}

// ToMessages implements the PromptValue interface.
// It typically converts the string into a single schema.HumanMessage.
// This behavior might need adjustment based on specific use cases in chains or agents.
func (spv StringPromptValue) ToMessages() []schema.Message {
	return []schema.Message{schema.NewHumanMessage(spv.Value)}
}

// ChatPromptValue holds a sequence of messages generated by a chat prompt template.
// This is used for chat-based LLMs.
type ChatPromptValue struct {
	Messages []schema.Message
}

// ToString implements the PromptValue interface.
// It provides a basic string representation of the chat messages, primarily for logging or debugging.
func (cpv ChatPromptValue) ToString() string {
	var builder strings.Builder
	for _, msg := range cpv.Messages {
		builder.WriteString(fmt.Sprintf("%s: %s\n", msg.GetType(), msg.GetContent()))
	}
	return builder.String()
}

// ToMessages implements the PromptValue interface.
func (cpv ChatPromptValue) ToMessages() []schema.Message {
	return cpv.Messages
}

// PromptTemplate defines the interface for all prompt templates.
// Prompt templates take input variables and format them into a PromptValue.
type PromptTemplate interface {
	core.Runnable // Input: map[string]any (variables), Output: PromptValue

	// Format takes a map of input variables and returns the formatted PromptValue.
	Format(ctx context.Context, variables map[string]any) (PromptValue, error)

	// InputVariables returns a list of the names of the variables the template expects.
	InputVariables() []string
}

// BasePromptTemplate provides common functionality for prompt templates,
// such as storing the list of expected input variables.
// Specific template types (like StringPromptTemplate, ChatPromptTemplate) can embed this.
type BasePromptTemplate struct {
	variables []string
	// TODO: Potentially add template format (e.g., "golang", "f-string") if supporting multiple syntaxes
}

// InputVariables returns the list of expected variable names.
func (bpt *BasePromptTemplate) InputVariables() []string {
	return bpt.variables
}

// --- String Prompt Template ---

// StringPromptTemplate formats a template string using Go's text/template package.
// It produces a StringPromptValue.
type StringPromptTemplate struct {
	BasePromptTemplate
	Template *template.Template // The parsed Go template
}

// NewStringPromptTemplate creates a new StringPromptTemplate from a template string.
// It parses the template string to identify variables (using a basic extraction method for now)
// and parses the template using Go's text/template.
func NewStringPromptTemplate(templateString string) (*StringPromptTemplate, error) {
	// Basic variable extraction (assuming {{.VarName}} syntax)
	// A more robust parser might be needed for complex cases or different syntaxes.
	vars := extractVariables(templateString) // Implementation needs refinement

	// Use Go's template engine
	tmpl, err := template.New("prompt").Parse(templateString)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template string: %w", err)
	}

	return &StringPromptTemplate{
		BasePromptTemplate: BasePromptTemplate{variables: vars},
		Template:           tmpl,
	}, nil
}

// Format implements the PromptTemplate interface.
func (spt *StringPromptTemplate) Format(ctx context.Context, variables map[string]any) (PromptValue, error) {
	var buf strings.Builder // Use strings.Builder which implements io.Writer

	// TODO: Validate that all required input variables are present in the map

	err := spt.Template.Execute(&buf, variables) // Pass buffer directly as io.Writer
	if err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return StringPromptValue{Value: buf.String()}, nil
}

// Invoke implements the core.Runnable interface for StringPromptTemplate.
func (spt *StringPromptTemplate) Invoke(ctx context.Context, input any, options ...core.Option) (any, error) {
	vars, ok := input.(map[string]any)
	if !ok {
		return nil, fmt.Errorf("input to StringPromptTemplate must be map[string]any, got %T", input)
	}
	return spt.Format(ctx, vars)
}

// Batch implements the core.Runnable interface for StringPromptTemplate.
func (spt *StringPromptTemplate) Batch(ctx context.Context, inputs []any, options ...core.Option) ([]any, error) {
	// Basic batch implementation by calling Invoke repeatedly.
	results := make([]any, len(inputs))
	var firstErr error
	for i, input := range inputs {
		output, err := spt.Invoke(ctx, input, options...)
		if err != nil && firstErr == nil {
			firstErr = err // Capture the first error
		}
		results[i] = output
	}
	return results, firstErr
}

// Stream implements the core.Runnable interface for StringPromptTemplate.
// Since template formatting is typically instantaneous, it returns the result immediately on a channel.
func (spt *StringPromptTemplate) Stream(ctx context.Context, input any, options ...core.Option) (<-chan any, error) {
	resultChan := make(chan any, 1)
	go func() {
		defer close(resultChan)
		output, err := spt.Invoke(ctx, input, options...)
		if err != nil {
			resultChan <- err // Send error on channel
		} else {
			resultChan <- output // Send result on channel
		}
	}()
	return resultChan, nil // Error is propagated via the channel
}

// --- Chat Prompt Template ---

// TODO: Implement ChatPromptTemplate similar to StringPromptTemplate.
// It should format input variables into a []schema.Message structure (ChatPromptValue).
// This will likely involve having template structures for individual messages (system, human, ai)
// within the overall chat template definition.

// Helper function to extract variables (basic example, needs robust implementation)
// A real implementation should parse the template syntax correctly.
func extractVariables(templateString string) []string {
	// Placeholder: Use regex or a proper parser to find {{.VarName}} patterns.
	vars := make(map[string]struct{})
	// Example crude regex:
	re := regexp.MustCompile(`{{\.([\w]+)}}`)
	matches := re.FindAllStringSubmatch(templateString, -1)
	for _, match := range matches {
		if len(match) > 1 {
			vars[match[1]] = struct{}{}
		}
	}

	varList := make([]string, 0, len(vars))
	for v := range vars {
		varList = append(varList, v)
	}
	return varList
}

// Compile-time checks to ensure implementations satisfy interfaces.
var _ PromptTemplate = (*StringPromptTemplate)(nil)
var _ core.Runnable = (*StringPromptTemplate)(nil)
var _ PromptValue = (*StringPromptValue)(nil)
var _ PromptValue = (*ChatPromptValue)(nil)
