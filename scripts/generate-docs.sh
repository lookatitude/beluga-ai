#!/bin/bash
# Script to generate API documentation for all packages using gomarkdoc
# This script generates markdown documentation from Go package godocs

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUTPUT_DIR="${ROOT_DIR}/website/docs/api/packages"
MODULE_NAME="github.com/lookatitude/beluga-ai"

echo -e "${GREEN}Generating API documentation...${NC}"

# Check if gomarkdoc is installed
if ! command -v gomarkdoc &> /dev/null; then
    echo -e "${YELLOW}gomarkdoc not found. Installing...${NC}"
    go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest
    # Add GOPATH/bin to PATH if gomarkdoc was just installed
    export PATH="${PATH}:$(go env GOPATH)/bin"
fi

# Create output directory if it doesn't exist
mkdir -p "${OUTPUT_DIR}"

# Function to generate docs for a package
generate_package_docs() {
    local pkg_path=$1
    local output_file=$2
    local pkg_name=$(basename "$pkg_path")
    
    echo -e "${GREEN}Generating docs for ${pkg_name}...${NC}"
    
    # Convert relative path to import path (pkg_path is already relative like "pkg/agents")
    local import_path="${MODULE_NAME}/${pkg_path}"
    
    # Find gomarkdoc binary
    local gomarkdoc_bin
    if command -v gomarkdoc &> /dev/null; then
        gomarkdoc_bin="gomarkdoc"
    elif [ -f "${HOME}/go/bin/gomarkdoc" ]; then
        gomarkdoc_bin="${HOME}/go/bin/gomarkdoc"
    elif [ -f "$(go env GOPATH)/bin/gomarkdoc" ]; then
        gomarkdoc_bin="$(go env GOPATH)/bin/gomarkdoc"
    else
        echo -e "${RED}gomarkdoc not found in PATH or GOPATH/bin${NC}"
        return 1
    fi
    
    # Generate markdown with gomarkdoc
    # Write to temp file first, then combine with frontmatter
    local temp_file=$(mktemp)
    
    # Change to root directory so gomarkdoc can resolve module paths correctly
    cd "${ROOT_DIR}" && "${gomarkdoc_bin}" --output "${temp_file}" --format github "${import_path}" 2>&1 || {
        rm -f "${temp_file}"
        echo -e "${RED}Failed to generate docs for ${pkg_name}${NC}" >&2
        echo -e "${YELLOW}Error logged for ${pkg_name}${NC}" >&2
        # Log failure to error file
        echo "$(date): Failed to generate docs for ${pkg_name} (${import_path})" >> "${ROOT_DIR}/docs-generation-errors.log" 2>/dev/null || true
        return 1
    }
    
    # Check if generation was successful
    if [ ! -s "${temp_file}" ] || [ "$(wc -l < "${temp_file}")" -lt 5 ]; then
        rm -f "${temp_file}"
        echo -e "${RED}Generated file for ${pkg_name} appears empty or incomplete${NC}"
        return 1
    fi
    
    # Combine frontmatter with generated content
    # Remove the gomarkdoc comment from temp file if it exists (we add our own)
    sed -i '/^<!-- Code generated by gomarkdoc\. DO NOT EDIT -->$/d' "${temp_file}"
    
    # Fix MDX compatibility issues in generated docs
    # Fix escaped parentheses (need to escape backslashes properly for sed)
    sed -i 's/\\\\(/(/g' "${temp_file}"
    sed -i 's/\\\\)/)/g' "${temp_file}"
    
    # Fix malformed summary text in details tags
    sed -i 's/Example ("atch)/Example (Batch)/g' "${temp_file}"
    sed -i 's/Example ("ind Tools)/Example (Bind Tools)/g' "${temp_file}"
    sed -i 's/Example (3tream Chat)/Example (Stream Chat)/g' "${temp_file}"
    
    # Convert <details> tags to headings for MDX compatibility
    # This removes collapsible functionality but ensures MDX can parse the file
    # Also fix escaped backslashes and JSX-like patterns in markdown links
    local python_script=$(mktemp)
    cat > "${python_script}" << 'PYTHON_EOF'
import re
import sys

temp_file = sys.argv[1]

with open(temp_file, 'r') as f:
    content = f.read()

# Convert <details><summary>...</summary>...content...</details> to ### Heading\n\n...content...
def replace_details(match):
    summary = match.group(1)
    content = match.group(2)
    summary_text = re.sub(r'<[^>]+>', '', summary).strip()
    return '\n\n### {}\n\n{}\n\n'.format(summary_text, content.strip())

content = re.sub(
    r'<details><summary>(.*?)</summary>\s*(.*?)</details>',
    replace_details,
    content,
    flags=re.DOTALL
)

# Remove any remaining <p> tags
content = re.sub(r'</?p>', '', content)

# Fix escaped backslashes in text (but preserve in code blocks)
# Pattern: \ followed by - (but not inside code blocks)
def fix_escaped_backslashes(text):
    lines = text.split('\n')
    in_code_block = False
    result = []
    
    for line in lines:
        # Track code block state
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            result.append(line)
            continue
        
        # Only fix escaped backslashes outside code blocks
        if not in_code_block:
            # Fix \- which is commonly used in godoc
            # This pattern matches a backslash followed by a hyphen
            # We need to be careful - in Python strings, \\ represents a single \
            line = line.replace('\\-', '-')
        
        result.append(line)
    
    return '\n'.join(result)

content = fix_escaped_backslashes(content)

# Fix JSX-like patterns in markdown links
# MDX tries to parse < and > as JSX, so we need to escape them in markdown links
# Pattern: [text](<#anchor>) where text contains < or > (like <\-chan)
def fix_jsx_in_links(text):
    # Find markdown links that contain < or > in the link text
    # Escape < and > in link text using HTML entities
    def escape_link_text(match):
        full_link = match.group(0)
        link_text = match.group(1)
        link_url = match.group(2)
        
        # If link text contains < or > (but not as part of HTML), escape them
        # This handles cases like <\-chan, <\-chan iface.AIMessageChunk, etc.
        if '<' in link_text or '>' in link_text:
            # Replace < with &lt; and > with &gt; in link text
            # But preserve existing HTML entities
            escaped_text = link_text.replace('<', '&lt;').replace('>', '&gt;')
            # Fix double-escaped entities
            escaped_text = escaped_text.replace('&amp;lt;', '&lt;').replace('&amp;gt;', '&gt;')
            return '[{}]({})'.format(escaped_text, link_url)
        
        return full_link
    
    # Match markdown links: [text](url)
    # Handle links with parentheses in the URL (like <#anchor>)
    result = re.sub(
        r'\[([^\]]+)\]\(([^)]+)\)',
        escape_link_text,
        text
    )
    
    return result

content = fix_jsx_in_links(content)

# Clean up multiple blank lines
content = re.sub(r'\n{3,}', '\n\n', content)

with open(temp_file, 'w') as f:
    f.write(content)
PYTHON_EOF
    
    python3 "${python_script}" "${temp_file}"
    rm -f "${python_script}"
    
    {
        echo "---"
        echo "title: ${pkg_name}"
        echo "sidebar_position: 1"
        echo "---"
        echo ""
        echo "<!-- Code generated by gomarkdoc. DO NOT EDIT -->"
        echo ""
        cat "${temp_file}"
    } > "${output_file}"
    
    rm -f "${temp_file}"
}

# Main packages to document
PACKAGES=(
    "pkg/agents"
    "pkg/chatmodels"
    "pkg/config"
    "pkg/core"
    "pkg/embeddings"
    "pkg/llms"
    "pkg/memory"
    "pkg/monitoring"
    "pkg/orchestration"
    "pkg/prompts"
    "pkg/retrievers"
    "pkg/schema"
    "pkg/server"
    "pkg/vectorstores"
)

# Generate docs for main packages
for pkg in "${PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${OUTPUT_DIR}/${pkg_name}.md"
    
    # Skip if package doesn't exist
    if [ ! -d "${ROOT_DIR}/${pkg}" ]; then
        echo -e "${YELLOW}Skipping ${pkg_name} (directory not found)${NC}"
        continue
    fi
    
    # Pass relative path, not absolute
    generate_package_docs "${pkg}" "${output_file}"
done

# Generate docs for LLM providers (subpackages)
LLM_PROVIDERS_DIR="${OUTPUT_DIR}/llms"
mkdir -p "${LLM_PROVIDERS_DIR}"

LLM_PROVIDERS=(
    "pkg/llms/providers/anthropic"
    "pkg/llms/providers/bedrock"
    "pkg/llms/providers/mock"
    "pkg/llms/providers/ollama"
    "pkg/llms/providers/openai"
)

for provider in "${LLM_PROVIDERS[@]}"; do
    provider_name=$(basename "$provider")
    output_file="${LLM_PROVIDERS_DIR}/${provider_name}.md"
    
    if [ ! -d "${ROOT_DIR}/${provider}" ]; then
        echo -e "${YELLOW}Skipping ${provider_name} (directory not found)${NC}"
        continue
    fi
    
    # Pass relative path, not absolute
    generate_package_docs "${provider}" "${output_file}"
done

# Generate docs for tools package (it's under agents/tools)
if [ -d "${ROOT_DIR}/pkg/agents/tools" ]; then
    output_file="${OUTPUT_DIR}/tools.md"
    generate_package_docs "pkg/agents/tools" "${output_file}"
fi

# Generate docs for voice packages
VOICE_DIR="${OUTPUT_DIR}/voice"
mkdir -p "${VOICE_DIR}"

VOICE_PACKAGES=(
    "pkg/voice/stt"
    "pkg/voice/tts"
    "pkg/voice/vad"
    "pkg/voice/turndetection"
    "pkg/voice/transport"
    "pkg/voice/noise"
    "pkg/voice/session"
)

for pkg in "${VOICE_PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${VOICE_DIR}/${pkg_name}.md"
    
    if [ ! -d "${ROOT_DIR}/${pkg}" ]; then
        echo -e "${YELLOW}Skipping ${pkg_name} (directory not found)${NC}"
        continue
    fi
    
    generate_package_docs "${pkg}" "${output_file}"
done

# Generate docs for RAG (retrievers + vectorstores combined concept)
# This is a conceptual package, so we'll create a combined doc
if [ -f "${OUTPUT_DIR}/retrievers.md" ] && [ -f "${OUTPUT_DIR}/vectorstores.md" ]; then
    echo -e "${GREEN}Creating RAG documentation...${NC}"
    {
        echo "---"
        echo "title: RAG"
        echo "sidebar_position: 1"
        echo "---"
        echo ""
        echo "# RAG (Retrieval Augmented Generation)"
        echo ""
        echo "RAG combines retrieval and generation capabilities. See the following packages:"
        echo ""
        echo "- [Retrievers](./retrievers) - Document retrieval components"
        echo "- [VectorStores](./vectorstores) - Vector storage and similarity search"
        echo ""
    } > "${OUTPUT_DIR}/rag.md"
fi

# Create llms_base.md if it doesn't exist (alias for llms package)
if [ ! -f "${OUTPUT_DIR}/llms_base.md" ]; then
    if [ -f "${OUTPUT_DIR}/llms.md" ]; then
        cp "${OUTPUT_DIR}/llms.md" "${OUTPUT_DIR}/llms_base.md"
        # Update title in frontmatter
        sed -i 's/title: llms/title: LLMs Base/' "${OUTPUT_DIR}/llms_base.md"
    fi
fi

# Validation step: verify all expected output files exist
echo -e "\n${GREEN}Validating generated documentation...${NC}"
VALIDATION_ERRORS=0
VALIDATION_WARNINGS=0

# Check main package files
for pkg in "${PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${OUTPUT_DIR}/${pkg_name}.md"
    if [ ! -f "${output_file}" ]; then
        echo -e "${YELLOW}Warning: Expected file not found: ${pkg_name}.md${NC}"
        ((VALIDATION_WARNINGS++))
    elif [ ! -s "${output_file}" ]; then
        echo -e "${RED}Error: File is empty: ${pkg_name}.md${NC}"
        ((VALIDATION_ERRORS++))
    fi
done

# Check LLM provider files
for provider in "${LLM_PROVIDERS[@]}"; do
    provider_name=$(basename "$provider")
    output_file="${LLM_PROVIDERS_DIR}/${provider_name}.md"
    if [ ! -f "${output_file}" ]; then
        echo -e "${YELLOW}Warning: Expected LLM provider file not found: ${provider_name}.md${NC}"
        ((VALIDATION_WARNINGS++))
    elif [ ! -s "${output_file}" ]; then
        echo -e "${RED}Error: LLM provider file is empty: ${provider_name}.md${NC}"
        ((VALIDATION_ERRORS++))
    fi
done

# Check voice package files
for pkg in "${VOICE_PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${VOICE_DIR}/${pkg_name}.md"
    if [ ! -f "${output_file}" ]; then
        echo -e "${YELLOW}Warning: Expected voice package file not found: ${pkg_name}.md${NC}"
        ((VALIDATION_WARNINGS++))
    elif [ ! -s "${output_file}" ]; then
        echo -e "${RED}Error: Voice package file is empty: ${pkg_name}.md${NC}"
        ((VALIDATION_ERRORS++))
    fi
done

# Summary report
echo -e "\n${GREEN}Documentation generation complete!${NC}"
echo -e "${GREEN}Generated docs are in: ${OUTPUT_DIR}${NC}"

# Count generated files
GENERATED_COUNT=$(find "${OUTPUT_DIR}" -name "*.md" -type f | wc -l)
echo -e "${GREEN}Total files generated: ${GENERATED_COUNT}${NC}"

if [ $VALIDATION_ERRORS -gt 0 ]; then
    echo -e "${RED}Validation failed with ${VALIDATION_ERRORS} error(s)${NC}"
    exit 1
elif [ $VALIDATION_WARNINGS -gt 0 ]; then
    echo -e "${YELLOW}Validation passed with ${VALIDATION_WARNINGS} warning(s)${NC}"
else
    echo -e "${GREEN}Validation passed: All expected files generated successfully${NC}"
fi
