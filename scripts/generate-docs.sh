#!/bin/bash
# Script to generate API documentation for all packages using gomarkdoc
# This script generates markdown documentation from Go package godocs

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUTPUT_DIR="${ROOT_DIR}/docs/api-docs/packages"
MODULE_NAME="github.com/lookatitude/beluga-ai"

echo -e "${GREEN}Generating API documentation...${NC}"

# Check if gomarkdoc is installed
if ! command -v gomarkdoc &> /dev/null; then
    echo -e "${YELLOW}gomarkdoc not found. Installing...${NC}"
    go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest
    # Add GOPATH/bin to PATH if gomarkdoc was just installed
    export PATH="${PATH}:$(go env GOPATH)/bin"
fi

# Create output directory if it doesn't exist
mkdir -p "${OUTPUT_DIR}"

# Function to generate docs for a package
generate_package_docs() {
    local pkg_path=$1
    local output_file=$2
    local pkg_name=$(basename "$pkg_path")
    
    echo -e "${GREEN}Generating docs for ${pkg_name}...${NC}"
    
    # Convert relative path to import path (pkg_path is already relative like "pkg/agents")
    local import_path="${MODULE_NAME}/${pkg_path}"
    
    # Find gomarkdoc binary
    local gomarkdoc_bin
    if command -v gomarkdoc &> /dev/null; then
        gomarkdoc_bin="gomarkdoc"
    elif [ -f "${HOME}/go/bin/gomarkdoc" ]; then
        gomarkdoc_bin="${HOME}/go/bin/gomarkdoc"
    elif [ -f "$(go env GOPATH)/bin/gomarkdoc" ]; then
        gomarkdoc_bin="$(go env GOPATH)/bin/gomarkdoc"
    else
        echo -e "${RED}gomarkdoc not found in PATH or GOPATH/bin${NC}"
        return 1
    fi
    
    # Generate markdown with gomarkdoc
    # Write to temp file first, then combine with frontmatter
    local temp_file=$(mktemp)
    
    # Change to root directory so gomarkdoc can resolve module paths correctly
    cd "${ROOT_DIR}" && "${gomarkdoc_bin}" --output "${temp_file}" --format github "${import_path}" 2>&1 || {
        rm -f "${temp_file}"
        echo -e "${RED}Failed to generate docs for ${pkg_name}${NC}" >&2
        echo -e "${YELLOW}Error logged for ${pkg_name}${NC}" >&2
        # Log failure to error file
        echo "$(date): Failed to generate docs for ${pkg_name} (${import_path})" >> "${ROOT_DIR}/docs-generation-errors.log" 2>/dev/null || true
        return 1
    }
    
    # Check if generation was successful
    if [ ! -s "${temp_file}" ] || [ "$(wc -l < "${temp_file}")" -lt 5 ]; then
        rm -f "${temp_file}"
        echo -e "${RED}Generated file for ${pkg_name} appears empty or incomplete${NC}"
        return 1
    fi
    
    # Combine frontmatter with generated content
    # Remove the gomarkdoc comment from temp file if it exists (we add our own)
    sed -i '/^<!-- Code generated by gomarkdoc\. DO NOT EDIT -->$/d' "${temp_file}"
    
    # Convert <details> tags to headings and fix MDX compatibility issues
    # This removes collapsible functionality but ensures MDX can parse the file
    # Also fix escaped backslashes and JSX-like patterns in markdown links
    local python_script=$(mktemp)
    cat > "${python_script}" << 'PYTHON_EOF'
import re
import sys

temp_file = sys.argv[1]

with open(temp_file, 'r') as f:
    content = f.read()

# 1. Convert <details><summary>...</summary>...content...</details> to ### Heading
def replace_details(match):
    summary = match.group(1)
    body = match.group(2)
    summary_text = re.sub(r'<[^>]+>', '', summary).strip()
    return '\n\n### {}\n\n{}\n\n'.format(summary_text, body.strip())

content = re.sub(
    r'<details><summary>(.*?)</summary>\s*(.*?)</details>',
    replace_details,
    content,
    flags=re.DOTALL
)

# 2. Remove remaining HTML tags
content = re.sub(r'</?p>', '', content)

# 3. Fix markdown link text containing Go syntax
# Pattern: [complex func signature](anchor) -> [`simplified`](anchor)
# Need to handle nested brackets in Go types like []string, []schema.Message
def fix_markdown_links(text):
    result = []
    i = 0
    while i < len(text):
        # Look for markdown link start
        if text[i] == '[' and (i == 0 or text[i-1] != '\\'):
            # Try to find the matching ] accounting for nested []
            bracket_depth = 1
            j = i + 1
            while j < len(text) and bracket_depth > 0:
                if text[j] == '[' and text[j-1] != '\\':
                    bracket_depth += 1
                elif text[j] == ']' and text[j-1] != '\\':
                    bracket_depth -= 1
                j += 1

            # Now j points right after the closing ]
            if j < len(text) and bracket_depth == 0 and text[j:j+2].startswith('(<'):
                # This is a markdown link with (<#anchor>) style
                link_text = text[i+1:j-1]
                # Find the closing )
                k = j + 1
                paren_depth = 1
                while k < len(text) and paren_depth > 0:
                    if text[k] == '(':
                        paren_depth += 1
                    elif text[k] == ')':
                        paren_depth -= 1
                    k += 1

                link_url = text[j+1:k-1]

                # Check if link text contains Go-specific patterns
                go_patterns = ['<-chan', 'chan<-', '[]', 'interface{}', 'map[', 'func ', '...']
                needs_backticks = any(p in link_text for p in go_patterns)

                # Also check for partially wrapped content (backtick mismatch)
                backtick_count = link_text.count('`')
                if backtick_count % 2 != 0:
                    needs_backticks = True

                if needs_backticks:
                    # Clean up and wrap in backticks
                    clean_text = link_text.replace('\\<', '<').replace('\\>', '>')
                    clean_text = clean_text.replace('\\[', '[').replace('\\]', ']')
                    clean_text = clean_text.replace('\\(', '(').replace('\\)', ')')
                    clean_text = clean_text.replace('\\*', '*').replace('\\-', '-')
                    clean_text = clean_text.replace('&lt;', '<').replace('&gt;', '>')
                    # Remove any existing backticks to avoid double-wrapping
                    clean_text = clean_text.replace('`', '')
                    result.append('[`{}`]({})'.format(clean_text, link_url))
                else:
                    result.append(text[i:k])

                i = k
                continue

        result.append(text[i])
        i += 1

    return ''.join(result)

content = fix_markdown_links(content)

# 4. Clean up escaped patterns and wrap MDX-problematic patterns outside code blocks
def clean_and_wrap_patterns(text):
    lines = text.split('\n')
    in_code_block = False
    result = []

    for line in lines:
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            result.append(line)
            continue

        if not in_code_block:
            # First pass: unescape common gomarkdoc escapes outside of inline code
            new_line = []
            in_inline_code = False
            i = 0
            while i < len(line):
                if line[i] == '`':
                    in_inline_code = not in_inline_code
                    new_line.append(line[i])
                elif not in_inline_code and line[i] == '\\' and i + 1 < len(line):
                    next_char = line[i + 1]
                    if next_char in '<>[]()-*':
                        new_line.append(next_char)
                        i += 1
                    else:
                        new_line.append(line[i])
                else:
                    new_line.append(line[i])
                i += 1
            line = ''.join(new_line)

            # Second pass: wrap MDX-problematic patterns in backticks
            # Only wrap if not already inside backticks
            # We need to find patterns outside of backticks and wrap them
            if '<-chan' in line or 'chan<-' in line or 'interface{}' in line:
                # Split line by backticks and process each segment
                parts = line.split('`')
                for idx in range(len(parts)):
                    # Even indices are outside backticks, odd indices are inside
                    if idx % 2 == 0:
                        # Wrap patterns in this segment
                        segment = parts[idx]
                        segment = re.sub(r'(<-chan\s*[a-zA-Z0-9_.\[\]]*)', r'`\1`', segment)
                        segment = re.sub(r'(chan<-\s*[a-zA-Z0-9_.\[\]]*)', r'`\1`', segment)
                        segment = re.sub(r'(interface\{\})', r'`\1`', segment)
                        parts[idx] = segment
                line = '`'.join(parts)

        result.append(line)

    return '\n'.join(result)

content = clean_and_wrap_patterns(content)

# 5. Clean up residual backslash escapes outside code blocks
def clean_backslash_escapes(text):
    lines = text.split('\n')
    in_code_block = False
    result = []

    for line in lines:
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            result.append(line)
            continue

        if not in_code_block:
            # Fix \- patterns
            line = line.replace('\\-', '-')
            # Fix remaining escaped parens/asterisks not in backticks
            # Only if they appear to be from gomarkdoc escaping
            if '\\(' in line or '\\)' in line or '\\*' in line:
                # Check if we're in inline code - if not, clean up
                # This is a simple heuristic - backtick count should be even
                if line.count('`') % 2 == 0:
                    line = line.replace('\\(', '(').replace('\\)', ')')
                    line = line.replace('\\*', '*')

        result.append(line)

    return '\n'.join(result)

content = clean_backslash_escapes(content)

# 6. Clean up multiple blank lines
content = re.sub(r'\n{3,}', '\n\n', content)

with open(temp_file, 'w') as f:
    f.write(content)
PYTHON_EOF
    
    python3 "${python_script}" "${temp_file}"
    rm -f "${python_script}"
    
    {
        echo "---"
        echo "title: ${pkg_name}"
        echo "sidebar_position: 1"
        echo "---"
        echo ""
        echo "<!-- Code generated by gomarkdoc. DO NOT EDIT -->"
        echo ""
        cat "${temp_file}"
    } > "${output_file}"
    
    rm -f "${temp_file}"
}

# Main packages to document
PACKAGES=(
    "pkg/agents"
    "pkg/chatmodels"
    "pkg/config"
    "pkg/core"
    "pkg/embeddings"
    "pkg/llms"
    "pkg/memory"
    "pkg/monitoring"
    "pkg/orchestration"
    "pkg/prompts"
    "pkg/retrievers"
    "pkg/schema"
    "pkg/server"
    "pkg/vectorstores"
)

# Generate docs for main packages
for pkg in "${PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${OUTPUT_DIR}/${pkg_name}.md"
    
    # Skip if package doesn't exist
    if [ ! -d "${ROOT_DIR}/${pkg}" ]; then
        echo -e "${YELLOW}Skipping ${pkg_name} (directory not found)${NC}"
        continue
    fi
    
    # Pass relative path, not absolute
    generate_package_docs "${pkg}" "${output_file}"
done

# Generate docs for LLM providers (subpackages)
LLM_PROVIDERS_DIR="${OUTPUT_DIR}/llms"
mkdir -p "${LLM_PROVIDERS_DIR}"

LLM_PROVIDERS=(
    "pkg/llms/providers/anthropic"
    "pkg/llms/providers/bedrock"
    "pkg/llms/providers/mock"
    "pkg/llms/providers/ollama"
    "pkg/llms/providers/openai"
)

for provider in "${LLM_PROVIDERS[@]}"; do
    provider_name=$(basename "$provider")
    output_file="${LLM_PROVIDERS_DIR}/${provider_name}.md"
    
    if [ ! -d "${ROOT_DIR}/${provider}" ]; then
        echo -e "${YELLOW}Skipping ${provider_name} (directory not found)${NC}"
        continue
    fi
    
    # Pass relative path, not absolute
    generate_package_docs "${provider}" "${output_file}"
done

# Generate docs for tools package (it's under agents/tools)
if [ -d "${ROOT_DIR}/pkg/agents/tools" ]; then
    output_file="${OUTPUT_DIR}/tools.md"
    generate_package_docs "pkg/agents/tools" "${output_file}"
fi

# Generate docs for voice packages
VOICE_DIR="${OUTPUT_DIR}/voice"
mkdir -p "${VOICE_DIR}"

VOICE_PACKAGES=(
    "pkg/voice/stt"
    "pkg/voice/tts"
    "pkg/voice/vad"
    "pkg/voice/turndetection"
    "pkg/voice/transport"
    "pkg/voice/noise"
    "pkg/voice/session"
)

for pkg in "${VOICE_PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${VOICE_DIR}/${pkg_name}.md"
    
    if [ ! -d "${ROOT_DIR}/${pkg}" ]; then
        echo -e "${YELLOW}Skipping ${pkg_name} (directory not found)${NC}"
        continue
    fi
    
    generate_package_docs "${pkg}" "${output_file}"
done

# Generate docs for RAG (retrievers + vectorstores combined concept)
# This is a conceptual package, so we'll create a combined doc
if [ -f "${OUTPUT_DIR}/retrievers.md" ] && [ -f "${OUTPUT_DIR}/vectorstores.md" ]; then
    echo -e "${GREEN}Creating RAG documentation...${NC}"
    {
        echo "---"
        echo "title: RAG"
        echo "sidebar_position: 1"
        echo "---"
        echo ""
        echo "# RAG (Retrieval Augmented Generation)"
        echo ""
        echo "RAG combines retrieval and generation capabilities. See the following packages:"
        echo ""
        echo "- [Retrievers](./retrievers) - Document retrieval components"
        echo "- [VectorStores](./vectorstores) - Vector storage and similarity search"
        echo ""
    } > "${OUTPUT_DIR}/rag.md"
fi

# Create llms_base.md if it doesn't exist (alias for llms package)
if [ ! -f "${OUTPUT_DIR}/llms_base.md" ]; then
    if [ -f "${OUTPUT_DIR}/llms.md" ]; then
        cp "${OUTPUT_DIR}/llms.md" "${OUTPUT_DIR}/llms_base.md"
        # Update title in frontmatter
        sed -i 's/title: llms/title: LLMs Base/' "${OUTPUT_DIR}/llms_base.md"
    fi
fi

# Validation step: verify all expected output files exist
echo -e "\n${GREEN}Validating generated documentation...${NC}"
VALIDATION_ERRORS=0
VALIDATION_WARNINGS=0

# Check main package files
for pkg in "${PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${OUTPUT_DIR}/${pkg_name}.md"
    if [ ! -f "${output_file}" ]; then
        echo -e "${YELLOW}Warning: Expected file not found: ${pkg_name}.md${NC}"
        ((VALIDATION_WARNINGS++))
    elif [ ! -s "${output_file}" ]; then
        echo -e "${RED}Error: File is empty: ${pkg_name}.md${NC}"
        ((VALIDATION_ERRORS++))
    fi
done

# Check LLM provider files
for provider in "${LLM_PROVIDERS[@]}"; do
    provider_name=$(basename "$provider")
    output_file="${LLM_PROVIDERS_DIR}/${provider_name}.md"
    if [ ! -f "${output_file}" ]; then
        echo -e "${YELLOW}Warning: Expected LLM provider file not found: ${provider_name}.md${NC}"
        ((VALIDATION_WARNINGS++))
    elif [ ! -s "${output_file}" ]; then
        echo -e "${RED}Error: LLM provider file is empty: ${provider_name}.md${NC}"
        ((VALIDATION_ERRORS++))
    fi
done

# Check voice package files
for pkg in "${VOICE_PACKAGES[@]}"; do
    pkg_name=$(basename "$pkg")
    output_file="${VOICE_DIR}/${pkg_name}.md"
    if [ ! -f "${output_file}" ]; then
        echo -e "${YELLOW}Warning: Expected voice package file not found: ${pkg_name}.md${NC}"
        ((VALIDATION_WARNINGS++))
    elif [ ! -s "${output_file}" ]; then
        echo -e "${RED}Error: Voice package file is empty: ${pkg_name}.md${NC}"
        ((VALIDATION_ERRORS++))
    fi
done

# Summary report
echo -e "\n${GREEN}Documentation generation complete!${NC}"
echo -e "${GREEN}Generated docs are in: ${OUTPUT_DIR}${NC}"

# Count generated files
GENERATED_COUNT=$(find "${OUTPUT_DIR}" -name "*.md" -type f | wc -l)
echo -e "${GREEN}Total files generated: ${GENERATED_COUNT}${NC}"

if [ $VALIDATION_ERRORS -gt 0 ]; then
    echo -e "${RED}Validation failed with ${VALIDATION_ERRORS} error(s)${NC}"
    exit 1
elif [ $VALIDATION_WARNINGS -gt 0 ]; then
    echo -e "${YELLOW}Validation passed with ${VALIDATION_WARNINGS} warning(s)${NC}"
else
    echo -e "${GREEN}Validation passed: All expected files generated successfully${NC}"
fi
