// Package memory defines interfaces and implementations for managing conversation history.
// Memory components allow agents and chains to retain information about past interactions.
package memory

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/lookatitude/beluga-ai/schema"
)

// BaseMemory defines the interface for all memory types.
// It specifies how memory variables are loaded and saved.
type BaseMemory interface {
	// MemoryVariables returns the list of variable names that this memory class will load
	// and make available to the prompt/chain/agent.
	MemoryVariables() []string

	// LoadMemoryVariables retrieves the context/history associated with the given input variables
	// and returns them as a map suitable for prompt formatting.
	// The `inputs` map might be used by some memory types to determine the context (e.g., session ID).
	LoadMemoryVariables(ctx context.Context, inputs map[string]any) (map[string]any, error)

	// SaveContext updates the memory state based on the inputs provided by the user
	// and the outputs generated by the model/chain.
	SaveContext(ctx context.Context, inputs map[string]any, outputs map[string]any) error

	// Clear completely wipes the memory state.
	Clear(ctx context.Context) error
}

// ChatMessageHistory defines the interface for storing a sequence of chat messages.
// This is often used as the underlying storage mechanism for various chat memory types.
type ChatMessageHistory interface {
	// AddUserMessage adds a message from the user (HumanMessage).
	AddUserMessage(ctx context.Context, message string) error
	// AddAIMessage adds a message from the AI (AIMessage).
	AddAIMessage(ctx context.Context, message string) error
	// AddMessage adds an arbitrary message object.
	AddMessage(ctx context.Context, message schema.Message) error
	// GetMessages retrieves all messages stored in the history.
	GetMessages(ctx context.Context) ([]schema.Message, error)
	// Clear removes all messages from the history.
	Clear(ctx context.Context) error
}

// SimpleChatMessageHistory provides a basic in-memory implementation of ChatMessageHistory.
// It stores messages in a simple slice.
type SimpleChatMessageHistory struct {
	mu       sync.RWMutex // Added mutex for thread safety
	Messages []schema.Message
}

// NewSimpleChatMessageHistory creates a new SimpleChatMessageHistory.
func NewSimpleChatMessageHistory() *SimpleChatMessageHistory {
	return &SimpleChatMessageHistory{
		Messages: make([]schema.Message, 0),
	}
}

// AddUserMessage adds a HumanMessage to the history.
func (h *SimpleChatMessageHistory) AddUserMessage(ctx context.Context, message string) error {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.Messages = append(h.Messages, schema.NewHumanMessage(message))
	return nil
}

// AddAIMessage adds an AIMessage to the history.
func (h *SimpleChatMessageHistory) AddAIMessage(ctx context.Context, message string) error {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.Messages = append(h.Messages, schema.NewAIMessage(message))
	return nil
}

// AddMessage adds any schema.Message to the history.
func (h *SimpleChatMessageHistory) AddMessage(ctx context.Context, message schema.Message) error {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.Messages = append(h.Messages, message)
	return nil
}

// GetMessages returns all messages in the history.
func (h *SimpleChatMessageHistory) GetMessages(ctx context.Context) ([]schema.Message, error) {
	h.mu.RLock()
	defer h.mu.RUnlock()
	// Return a copy to prevent external modification of the internal slice
	msgsCopy := make([]schema.Message, len(h.Messages))
	copy(msgsCopy, h.Messages)
	return msgsCopy, nil
}

// Clear removes all messages from the history.
func (h *SimpleChatMessageHistory) Clear(ctx context.Context) error {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.Messages = make([]schema.Message, 0)
	return nil
}

// Ensure SimpleChatMessageHistory implements the interface.
var _ ChatMessageHistory = (*SimpleChatMessageHistory)(nil)

// --- Utility Functions ---

// GetBufferString formats a slice of chat messages into a single string.
// It includes prefixes for Human and AI messages.
func GetBufferString(messages []schema.Message, humanPrefix string, aiPrefix string) string {
	var buffer string
	for _, m := range messages {
		var role string
		switch m.GetType() {
		case schema.MessageTypeHuman:
			role = humanPrefix
		case schema.MessageTypeAI:
			role = aiPrefix
		default:
			// Skip other message types for simple buffer string
			continue
		}
		buffer += fmt.Sprintf("%s: %s\n", role, m.GetContent())
	}
	return buffer
}

// GetInputOutputKeys extracts the input and output keys from the provided maps.
// It assumes single input and output keys if not specified in the memory object.
// TODO: Make this more robust, potentially using memory configuration.
func GetInputOutputKeys(inputs map[string]any, outputs map[string]any) (inputKey, outputKey string, err error) {
	if len(inputs) == 1 {
		for k := range inputs {
			inputKey = k
		}
	} else {
		// Try common keys or require explicit configuration
		if _, ok := inputs["input"]; ok {
			inputKey = "input"
		} else if _, ok := inputs["question"]; ok {
			inputKey = "question"
		} else {
			return "", "", errors.New("could not determine input key from multiple inputs")
		}
	}

	if len(outputs) == 1 {
		for k := range outputs {
			outputKey = k
		}
	} else {
		// Try common keys or require explicit configuration
		if _, ok := outputs["output"]; ok {
			outputKey = "output"
		} else if _, ok := outputs["answer"]; ok {
			outputKey = "answer"
		} else {
			return "", "", errors.New("could not determine output key from multiple outputs")
		}
	}
	return inputKey, outputKey, nil
}

// TODO:
// - Implement ConversationBufferMemory in buffer.go
// - Implement ConversationSummaryMemory in summary.go (requires LLM)
// - Implement ConversationBufferWindowMemory in window.go
// - Implement ConversationSummaryBufferMemory in summary_buffer.go (requires LLM)
// - Implement VectorStoreMemory in vectorstore.go (requires VectorStore)
// - Consider interfaces/implementations for persisting memory (e.g., to DB, file)
