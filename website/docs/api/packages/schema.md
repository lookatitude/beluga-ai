<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# schema

```go
import "github.com/lookatitude/beluga-ai/schema"
```

Package schema defines core data structures used throughout the framework.

Package schema defines core data structures used throughout the Beluga\-ai framework, such as messages, documents, and tool definitions.

## Index

- [func MessagesToString\(messages \[\]Message, humanPrefix, aiPrefix string\) string](<#MessagesToString>)
- [type AIMessage](<#AIMessage>)
  - [func NewAIMessage\(content string\) \*AIMessage](<#NewAIMessage>)
  - [func NewAIMessageWithToolCalls\(content string, toolCalls \[\]ToolCall\) \*AIMessage](<#NewAIMessageWithToolCalls>)
  - [func \(m \*AIMessage\) GetAdditionalArgs\(\) map\[string\]any](<#AIMessage.GetAdditionalArgs>)
- [type BaseMessage](<#BaseMessage>)
  - [func \(m BaseMessage\) GetAdditionalArgs\(\) map\[string\]any](<#BaseMessage.GetAdditionalArgs>)
  - [func \(m BaseMessage\) GetContent\(\) string](<#BaseMessage.GetContent>)
  - [func \(m BaseMessage\) GetType\(\) MessageType](<#BaseMessage.GetType>)
- [type Document](<#Document>)
  - [func NewDocument\(pageContent string, metadata map\[string\]any\) Document](<#NewDocument>)
  - [func \(d Document\) GetAdditionalArgs\(\) map\[string\]any](<#Document.GetAdditionalArgs>)
  - [func \(d Document\) GetContent\(\) string](<#Document.GetContent>)
  - [func \(d Document\) GetType\(\) MessageType](<#Document.GetType>)
- [type GenericMessage](<#GenericMessage>)
  - [func NewGenericMessage\(content, role string\) \*GenericMessage](<#NewGenericMessage>)
  - [func \(m \*GenericMessage\) GetAdditionalArgs\(\) map\[string\]any](<#GenericMessage.GetAdditionalArgs>)
- [type HumanMessage](<#HumanMessage>)
  - [func NewHumanMessage\(content string\) \*HumanMessage](<#NewHumanMessage>)
- [type Message](<#Message>)
- [type MessageType](<#MessageType>)
- [type SystemMessage](<#SystemMessage>)
  - [func NewSystemMessage\(content string\) \*SystemMessage](<#NewSystemMessage>)
- [type ToolCall](<#ToolCall>)
- [type ToolCallChunk](<#ToolCallChunk>)
- [type ToolMessage](<#ToolMessage>)
  - [func NewToolMessage\(content, toolCallID string\) \*ToolMessage](<#NewToolMessage>)
  - [func \(m \*ToolMessage\) GetAdditionalArgs\(\) map\[string\]any](<#ToolMessage.GetAdditionalArgs>)


<a name="MessagesToString"></a>
## func MessagesToString

```go
func MessagesToString(messages []Message, humanPrefix, aiPrefix string) string
```

MessagesToString converts a slice of messages into a single formatted string. Useful for simple logging or display, but loses structural information.

<a name="AIMessage"></a>
## type AIMessage

AIMessage represents a message generated by the AI model. It may optionally include requests to call tools.

```go
type AIMessage struct {
    BaseMessage
    // ToolCalls contains a list of tool calls requested by the AI in this message.
    // This field is populated when the AI decides to use one or more tools.
    ToolCalls []ToolCall `json:"tool_calls,omitempty"`
    // AdditionalArgs can store provider-specific information, like token usage.
    AdditionalArgs map[string]any `json:"additional_args,omitempty"`
}
```

<a name="NewAIMessage"></a>
### func NewAIMessage

```go
func NewAIMessage(content string) *AIMessage
```

NewAIMessage creates a new AIMessage with text content.

<a name="NewAIMessageWithToolCalls"></a>
### func NewAIMessageWithToolCalls

```go
func NewAIMessageWithToolCalls(content string, toolCalls []ToolCall) *AIMessage
```

NewAIMessageWithToolCalls creates a new AIMessage that includes tool call requests. Content can be empty if the message only contains tool calls.

<a name="AIMessage.GetAdditionalArgs"></a>
### func \(\*AIMessage\) GetAdditionalArgs

```go
func (m *AIMessage) GetAdditionalArgs() map[string]any
```

GetAdditionalArgs implements the Message interface for AIMessage. It includes ToolCalls \(if any\) and other arguments from the AdditionalArgs field.

<a name="BaseMessage"></a>
## type BaseMessage

BaseMessage provides a common structure that specific message types can embed. It includes the fundamental Type and Content fields.

```go
type BaseMessage struct {
    Type    MessageType `json:"type"`    // The role of the message (system, human, ai, etc.)
    Content string      `json:"content"` // The text content of the message
}
```

<a name="BaseMessage.GetAdditionalArgs"></a>
### func \(BaseMessage\) GetAdditionalArgs

```go
func (m BaseMessage) GetAdditionalArgs() map[string]any
```

GetAdditionalArgs implements the Message interface for BaseMessage. Base messages have no additional arguments by default.

<a name="BaseMessage.GetContent"></a>
### func \(BaseMessage\) GetContent

```go
func (m BaseMessage) GetContent() string
```

GetContent implements the Message interface for BaseMessage.

<a name="BaseMessage.GetType"></a>
### func \(BaseMessage\) GetType

```go
func (m BaseMessage) GetType() MessageType
```

GetType implements the Message interface for BaseMessage.

<a name="Document"></a>
## type Document

Document represents a piece of text, often with associated metadata. It can be used for retrieved context in RAG or as input/output for chains.

```go
type Document struct {
    PageContent string
    Metadata    map[string]any
}
```

<a name="NewDocument"></a>
### func NewDocument

```go
func NewDocument(pageContent string, metadata map[string]any) Document
```



<a name="Document.GetAdditionalArgs"></a>
### func \(Document\) GetAdditionalArgs

```go
func (d Document) GetAdditionalArgs() map[string]any
```

GetAdditionalArgs returns additional arguments associated with the message. For Document, this is typically nil or an empty map.

<a name="Document.GetContent"></a>
### func \(Document\) GetContent

```go
func (d Document) GetContent() string
```

GetContent returns the main text content of the document. This allows Document to be used somewhat interchangeably with Message in some contexts.

<a name="Document.GetType"></a>
### func \(Document\) GetType

```go
func (d Document) GetType() MessageType
```

GetType returns a specific type identifier for Document, fulfilling the Message interface. Note: This might be conceptually slightly awkward, but allows using Documents where Messages are expected. Consider if a different interface or approach is better long\-term.

<a name="GenericMessage"></a>
## type GenericMessage

GenericMessage represents a message with a custom or non\-standard role. Useful for loading chat history from formats not strictly adhering to System/Human/AI/Tool roles.

```go
type GenericMessage struct {
    BaseMessage
    Role string `json:"role"` // The custom role name.
}
```

<a name="NewGenericMessage"></a>
### func NewGenericMessage

```go
func NewGenericMessage(content, role string) *GenericMessage
```

NewGenericMessage creates a new GenericMessage.

<a name="GenericMessage.GetAdditionalArgs"></a>
### func \(\*GenericMessage\) GetAdditionalArgs

```go
func (m *GenericMessage) GetAdditionalArgs() map[string]any
```

GetAdditionalArgs implements the Message interface for GenericMessage. It includes the custom Role.

<a name="HumanMessage"></a>
## type HumanMessage

HumanMessage represents a message from the human user interacting with the AI.

```go
type HumanMessage struct {
    BaseMessage
}
```

<a name="NewHumanMessage"></a>
### func NewHumanMessage

```go
func NewHumanMessage(content string) *HumanMessage
```

NewHumanMessage creates a new HumanMessage.

<a name="Message"></a>
## type Message

Message represents a single message within a chat conversation. It defines the common interface that all specific message types must implement.

```go
type Message interface {
    // GetType returns the type/role of the message (e.g., system, human, ai).
    GetType() MessageType
    // GetContent returns the textual content of the message.
    GetContent() string
    // GetAdditionalArgs returns any additional arguments associated with the message.
    // This allows specific message types (like AIMessage with ToolCalls or ToolMessage with ToolCallID)
    // to expose their unique data in a generic way, useful for serialization or logging.
    GetAdditionalArgs() map[string]any
}
```

<a name="MessageType"></a>
## type MessageType

MessageType defines the type or role of a message in a conversation sequence. This helps models understand the context and source of each message.

```go
type MessageType string
```

<a name="MessageTypeSystem"></a>Constants defining standard message types.

```go
const (
    // MessageTypeSystem represents a message providing instructions or context to the AI model.
    MessageTypeSystem MessageType = "system"
    // MessageTypeHuman represents a message originating from the human user.
    MessageTypeHuman MessageType = "human"
    // MessageTypeAI represents a message originating from the AI model.
    MessageTypeAI MessageType = "ai"
    // MessageTypeTool represents the result or observation obtained from executing a tool.
    MessageTypeTool MessageType = "tool"
    // MessageTypeGeneric represents a message whose role doesn_t fit the standard types.
    // Useful for compatibility when loading chat history from diverse formats.
    MessageTypeGeneric MessageType = "generic"
)
```

<a name="SystemMessage"></a>
## type SystemMessage

SystemMessage represents a message setting the context or instructions for the AI. Typically appears at the beginning of a conversation.

```go
type SystemMessage struct {
    BaseMessage
}
```

<a name="NewSystemMessage"></a>
### func NewSystemMessage

```go
func NewSystemMessage(content string) *SystemMessage
```

NewSystemMessage creates a new SystemMessage.

<a name="ToolCall"></a>
## type ToolCall

ToolCall represents a request from the AI model to invoke a specific tool \(function\).

```go
type ToolCall struct {
    // ID is a unique identifier for this specific tool call instance.
    // It_s used to associate the call request in an AIMessage with the corresponding result in a ToolMessage.
    ID  string `json:"id"`
    // Name is the name of the tool (function) to be called.
    Name string `json:"name"`
    // Arguments is a string containing the arguments for the tool call, typically formatted as a JSON object.
    // The specific structure depends on the tool_s definition.
    Arguments string `json:"arguments"`
}
```

<a name="ToolCallChunk"></a>
## type ToolCallChunk

ToolCallChunk represents a part of a tool call, used in streaming responses. It allows for incremental construction of a tool call.

```go
type ToolCallChunk struct {
    // Name is the name of the tool. This may be nil if the chunk is part of an argument stream.
    Name *string `json:"name,omitempty"`
    // Arguments is a chunk of the arguments for the tool call.
    // For JSON arguments, this will be a partial JSON string.
    Arguments string `json:"arguments,omitempty"`
    // ID is the unique identifier for the tool call this chunk belongs to.
    // This should be consistent across all chunks for a single tool call.
    ID  string `json:"id,omitempty"`
    // Index is the index of the tool call in a sequence of multiple tool calls.
    // This is useful if the model can request multiple tools in parallel streams.
    Index *int `json:"index,omitempty"`
}
```

<a name="ToolMessage"></a>
## type ToolMessage

ToolMessage represents the result returned from executing a tool call requested by the AI.

```go
type ToolMessage struct {
    BaseMessage
    // ToolCallID is the ID from the corresponding ToolCall in the AIMessage.
    // This links the result back to the specific request.
    ToolCallID string `json:"tool_call_id"`
}
```

<a name="NewToolMessage"></a>
### func NewToolMessage

```go
func NewToolMessage(content, toolCallID string) *ToolMessage
```

NewToolMessage creates a new ToolMessage.

<a name="ToolMessage.GetAdditionalArgs"></a>
### func \(\*ToolMessage\) GetAdditionalArgs

```go
func (m *ToolMessage) GetAdditionalArgs() map[string]any
```

GetAdditionalArgs implements the Message interface for ToolMessage. It includes the ToolCallID.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
