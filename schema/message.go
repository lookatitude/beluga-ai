// Package schema defines core data structures used throughout the Beluga-ai framework,
// such as messages, documents, and tool definitions.
package schema

// MessageType defines the type or role of a message in a conversation sequence.
// This helps models understand the context and source of each message.
type MessageType string

// Constants defining standard message types.
const (
	// MessageTypeSystem represents a message providing instructions or context to the AI model.
	MessageTypeSystem MessageType = "system"
	// MessageTypeHuman represents a message originating from the human user.
	MessageTypeHuman MessageType = "human"
	// MessageTypeAI represents a message originating from the AI model.
	MessageTypeAI MessageType = "ai"
	// MessageTypeTool represents the result or observation obtained from executing a tool.
	MessageTypeTool MessageType = "tool"
	// MessageTypeGeneric represents a message whose role doesn_t fit the standard types.
	// Useful for compatibility when loading chat history from diverse formats.
	MessageTypeGeneric MessageType = "generic"
)

// Message represents a single message within a chat conversation.
// It defines the common interface that all specific message types must implement.
type Message interface {
	// GetType returns the type/role of the message (e.g., system, human, ai).
	GetType() MessageType
	// GetContent returns the textual content of the message.
	GetContent() string
	// GetAdditionalArgs returns any additional arguments associated with the message.
	// This allows specific message types (like AIMessage with ToolCalls or ToolMessage with ToolCallID)
	// to expose their unique data in a generic way, useful for serialization or logging.
	GetAdditionalArgs() map[string]any
}

// BaseMessage provides a common structure that specific message types can embed.
// It includes the fundamental Type and Content fields.
type BaseMessage struct {
	Type    MessageType `json:"type"`    // The role of the message (system, human, ai, etc.)
	Content string      `json:"content"` // The text content of the message
}

// GetType implements the Message interface for BaseMessage.
func (m BaseMessage) GetType() MessageType {
	return m.Type
}

// GetContent implements the Message interface for BaseMessage.
func (m BaseMessage) GetContent() string {
	return m.Content
}

// GetAdditionalArgs implements the Message interface for BaseMessage.
// Base messages have no additional arguments by default.
func (m BaseMessage) GetAdditionalArgs() map[string]any {
	return nil
}

// SystemMessage represents a message setting the context or instructions for the AI.
// Typically appears at the beginning of a conversation.
type SystemMessage struct {
	BaseMessage
}

// NewSystemMessage creates a new SystemMessage.
func NewSystemMessage(content string) *SystemMessage {
	return &SystemMessage{BaseMessage{Type: MessageTypeSystem, Content: content}}
}

// HumanMessage represents a message from the human user interacting with the AI.
type HumanMessage struct {
	BaseMessage
}

// NewHumanMessage creates a new HumanMessage.
func NewHumanMessage(content string) *HumanMessage {
	return &HumanMessage{BaseMessage{Type: MessageTypeHuman, Content: content}}
}

// ToolCall represents a request from the AI model to invoke a specific tool (function).
type ToolCall struct {
	// ID is a unique identifier for this specific tool call instance.
	// It_s used to associate the call request in an AIMessage with the corresponding result in a ToolMessage.
	ID string `json:"id"`
	// Name is the name of the tool (function) to be called.
	Name string `json:"name"`
	// Arguments is a string containing the arguments for the tool call, typically formatted as a JSON object.
	// The specific structure depends on the tool_s definition.
	Arguments string `json:"arguments"`
}

// ToolCallChunk represents a part of a tool call, used in streaming responses.
// It allows for incremental construction of a tool call.
type ToolCallChunk struct {
	// Name is the name of the tool. This may be nil if the chunk is part of an argument stream.
	Name *string `json:"name,omitempty"`
	// Arguments is a chunk of the arguments for the tool call.
	// For JSON arguments, this will be a partial JSON string.
	Arguments string `json:"arguments,omitempty"`
	// ID is the unique identifier for the tool call this chunk belongs to.
	// This should be consistent across all chunks for a single tool call.
	ID string `json:"id,omitempty"`
	// Index is the index of the tool call in a sequence of multiple tool calls.
	// This is useful if the model can request multiple tools in parallel streams.
	Index *int `json:"index,omitempty"`
}

// AIMessage represents a message generated by the AI model.
// It may optionally include requests to call tools.
type AIMessage struct {
	BaseMessage
	// ToolCalls contains a list of tool calls requested by the AI in this message.
	// This field is populated when the AI decides to use one or more tools.
	ToolCalls []ToolCall `json:"tool_calls,omitempty"`
	// AdditionalArgs can store provider-specific information, like token usage.
	AdditionalArgs map[string]any `json:"additional_args,omitempty"`
}

// NewAIMessage creates a new AIMessage with text content.
func NewAIMessage(content string) *AIMessage {
	return &AIMessage{
		BaseMessage: BaseMessage{Type: MessageTypeAI, Content: content},
		AdditionalArgs: make(map[string]any), // Initialize the map
	}
}

// NewAIMessageWithToolCalls creates a new AIMessage that includes tool call requests.
// Content can be empty if the message only contains tool calls.
func NewAIMessageWithToolCalls(content string, toolCalls []ToolCall) *AIMessage {
	return &AIMessage{
		BaseMessage: BaseMessage{Type: MessageTypeAI, Content: content},
		ToolCalls:   toolCalls,
		AdditionalArgs: make(map[string]any), // Initialize the map
	}
}

// GetAdditionalArgs implements the Message interface for AIMessage.
// It includes ToolCalls (if any) and other arguments from the AdditionalArgs field.
func (m *AIMessage) GetAdditionalArgs() map[string]any {
	args := make(map[string]any)

	// Copy from m.AdditionalArgs first
	for k, v := range m.AdditionalArgs {
		args[k] = v
	}

	// Add tool_calls if they exist, potentially overwriting if key conflicts (unlikely)
	if len(m.ToolCalls) > 0 {
		args["tool_calls"] = m.ToolCalls
	}

	if len(args) == 0 {
		return nil // Return nil if the map is empty to match BaseMessage behavior
	}
	return args
}

// ToolMessage represents the result returned from executing a tool call requested by the AI.
type ToolMessage struct {
	BaseMessage
	// ToolCallID is the ID from the corresponding ToolCall in the AIMessage.
	// This links the result back to the specific request.
	ToolCallID string `json:"tool_call_id"`
}

// NewToolMessage creates a new ToolMessage.
func NewToolMessage(content, toolCallID string) *ToolMessage {
	return &ToolMessage{
		BaseMessage: BaseMessage{Type: MessageTypeTool, Content: content},
		ToolCallID:  toolCallID,
	}
}

// GetAdditionalArgs implements the Message interface for ToolMessage.
// It includes the ToolCallID.
func (m *ToolMessage) GetAdditionalArgs() map[string]any {
	// Always return the ToolCallID
	return map[string]any{"tool_call_id": m.ToolCallID}
}

// GenericMessage represents a message with a custom or non-standard role.
// Useful for loading chat history from formats not strictly adhering to System/Human/AI/Tool roles.
type GenericMessage struct {
	BaseMessage
	Role string `json:"role"` // The custom role name.
}

// NewGenericMessage creates a new GenericMessage.
func NewGenericMessage(content, role string) *GenericMessage {
	return &GenericMessage{
		BaseMessage: BaseMessage{Type: MessageTypeGeneric, Content: content},
		Role:        role,
	}
}

// GetAdditionalArgs implements the Message interface for GenericMessage.
// It includes the custom Role.
func (m *GenericMessage) GetAdditionalArgs() map[string]any {
	// Always return the Role
	return map[string]any{"role": m.Role}
}

// Compile-time check to ensure all concrete message types implement the Message interface.
var _ Message = (*SystemMessage)(nil)
var _ Message = (*HumanMessage)(nil)
var _ Message = (*AIMessage)(nil)
var _ Message = (*ToolMessage)(nil)
var _ Message = (*GenericMessage)(nil)

// --- Utility Functions ---

// MessagesToString converts a slice of messages into a single formatted string.
// Useful for simple logging or display, but loses structural information.
func MessagesToString(messages []Message, humanPrefix, aiPrefix string) string {
	var result string
	for _, m := range messages {
		// Placeholder to avoid unused variable error for m during cleanup
		_ = m 
	}
	return result
}

// StringToMessages is intentionally omitted as parsing free-form text back into
// structured messages is ambiguous and error-prone. Use structured formats like JSON
// for serialization and deserialization.

